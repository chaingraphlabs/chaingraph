/*
 * Copyright (c) 2025 BadLabs
 *
 * Use of this software is governed by the Business Source License 1.1 included in the file LICENSE.txt.
 *
 * As of the Change Date specified in that file, in accordance with the Business Source License, use of this software will be governed by the Apache License, version 2.0.
 */

import type { BaseNode, INode, IPort } from '@badaitech/chaingraph-types'
import { findPort } from '@badaitech/chaingraph-types'
import {
  isAnyPortConfig,
  isArrayPortConfig,
  isBooleanPortConfig,
  isEnumPortConfig,
  isNumberPortConfig,
  isObjectPortConfig,
  isStringPortConfig,
} from '@badaitech/chaingraph-types'

export interface ExtractedSchema {
  properties: Record<string, any>
  required: string[]
  outputProperties: Record<string, any>
  outputRequired: string[]
  metadata: {
    nodeTitle: string
    nodeDescription?: string
    originalNodeId: string
    originalNodeType: string
    extractedAt: string
  }
}

export interface SchemaProperty {
  type?: string
  title?: string
  description?: string
  default?: any
  properties?: Record<string, SchemaProperty>
  items?: SchemaProperty
  // String properties
  minLength?: number
  maxLength?: number
  pattern?: string
  // Number properties
  minimum?: number
  maximum?: number
  multipleOf?: number
  // Array properties
  minItems?: number
  maxItems?: number
  // Enum properties
  enum?: string[]
  enumTitles?: string[]
  // Object-level required (for object types only)
  required?: string[]
}

/**
 * Extracts input and output schema from a node for tool definition
 * Converts node's input and output ports to JSON schema format
 */
export function extractNodeSchema(node: INode): ExtractedSchema {
  // Get all ports from the node
  const allPorts = Array.from(node.ports.values())
    .filter(port => !port.getConfig().parentId) // Only root-level ports

  // Separate input and output ports
  const inputPorts = allPorts.filter(port => port.getConfig().direction === 'input' || port.getConfig().direction === 'passthrough')
  const outputPorts = allPorts.filter(port => port.getConfig().direction === 'output')

  // Process input ports
  const properties: Record<string, SchemaProperty> = {}
  const required: string[] = []

  for (const port of inputPorts) {
    const config = port.getConfig()
    const key = config.key || port.id

    // Skip hidden ports
    if (isNeedsToSkipPort(node, port)) {
      continue
    }

    // Extract schema property from port
    properties[key] = portConfigToJsonSchema(node, port)

    // Add to required if marked as required
    if (config.required) {
      required.push(key)
    }
  }

  // Process output ports
  const outputProperties: Record<string, SchemaProperty> = {}
  const outputRequired: string[] = []

  for (const port of outputPorts) {
    const config = port.getConfig()
    const key = config.key || port.id

    if (isNeedsToSkipPort(node, port)) {
      continue
    }

    // Extract schema property from port
    outputProperties[key] = portConfigToJsonSchema(node, port)

    // Add to required if marked as required
    if (config.required) {
      outputRequired.push(key)
    }
  }

  return {
    properties,
    required,
    outputProperties,
    outputRequired,
    metadata: {
      nodeTitle: node.metadata.title || 'Untitled Node',
      nodeDescription: node.metadata.description,
      originalNodeId: node.id,
      originalNodeType: node.metadata.type,
      extractedAt: new Date().toISOString(),
    },
  }
}

export function isNeedsToSkipPort(
  node: INode,
  port: IPort,
): boolean {
  const config = port.getConfig()

  if (port.getConfig().type === 'stream' || port.getConfig().type === 'secret') {
    return true
  }

  // Skip ports that are connected to other ports
  if (config.connections && (config.connections?.length || 0) > 0) {
    return true
  }

  const value = port.getValue()

  if (config.type === 'string') {
    if (value !== undefined && value !== null && value !== '') {
      // Skip string properties that are not empty
      return true
    }
  } else if (config.type === 'number') {
    if (value !== undefined && value !== null && value !== 0) {
      // Skip number properties that are not null or undefined
      return true
    }
  }

  // Skip ports that are hidden
  if (config.ui?.hidden) {
    return true
  }

  // Skip system ports
  if (config.metadata?.isSystemPort) {
    return true
  }

  return false
}

/**
 * Converts a port configuration to JSON schema format
 */
export function portConfigToJsonSchema(
  node: INode,
  port: IPort,
): SchemaProperty {
  const config = port.getConfig()
  const value = port.getValue()

  // Base properties all ports have
  const baseProperty: SchemaProperty = {
    title: config.title || port.id,
    description: config.description || config.title || '',
  }

  // Add value as default if it exists
  if (value !== undefined && value !== null && value !== '' && value !== 0) {
    baseProperty.default = value
  } else if (config.defaultValue !== undefined && config.defaultValue !== null && config.defaultValue !== '' && config.defaultValue !== 0) {
    baseProperty.default = config.defaultValue
  }

  // Handle different port types
  if (isStringPortConfig(config)) {
    return {
      ...baseProperty,
      type: 'string',
      ...(config.minLength !== undefined && { minLength: config.minLength }),
      ...(config.maxLength !== undefined && { maxLength: config.maxLength }),
      ...(config.pattern && { pattern: config.pattern }),
    }
  }

  if (isNumberPortConfig(config)) {
    return {
      ...baseProperty,
      type: config.integer ? 'integer' : 'number',
      ...(config.min !== undefined && { minimum: config.min }),
      ...(config.max !== undefined && { maximum: config.max }),
      ...(config.step !== undefined && { multipleOf: config.step }),
    }
  }

  if (isBooleanPortConfig(config)) {
    return {
      ...baseProperty,
      type: 'boolean',
    }
  }

  if (isEnumPortConfig(config)) {
    const enumValues = config.options
      .map(option => option.id || option.defaultValue)
      .filter((id): id is string => Boolean(id))

    const enumTitles = config.options
      .map(option => option.title || option.id || option.defaultValue)
      .filter((title): title is string => Boolean(title))

    const res: SchemaProperty = {
      ...baseProperty,
      type: 'string',
    }

    if (enumValues.length > 0) {
      res.enum = enumValues
      res.enumTitles = enumTitles
    }

    return res
  }

  if (isArrayPortConfig(config)) {
    // For arrays, we need to process the item type recursively
    // Create a mock port for the item config to process it
    const itemProperty = processItemConfig(config.itemConfig)

    return {
      ...baseProperty,
      type: 'array',
      items: itemProperty,
      ...(config.minLength !== undefined && { minItems: config.minLength }),
      ...(config.maxLength !== undefined && { maxItems: config.maxLength }),
    }
  }

  if (isObjectPortConfig(config)) {
    // console.log(`[portConfigToJsonSchema] Processing object port: ${port.id} (${node.id}), NODE: ${JSON.stringify(node.serialize())}`)
    return processObjectPort(node as BaseNode, port)
  }

  if (isAnyPortConfig(config)) {
    // For any type, we can return a generic object schema
    return {
      ...baseProperty,
      type: 'any',
    }
  }

  // Fallback for any unknown types
  return baseProperty
}

/**
 * Helper function to process item configs for arrays
 */
function processItemConfig(itemConfig: any): SchemaProperty {
  if (!itemConfig || typeof itemConfig !== 'object') {
    return {
      type: 'string',
      description: 'Array item',
    }
  }

  const baseProperty: SchemaProperty = {
    title: itemConfig.title || 'Array item',
    description: itemConfig.description || '',
  }

  // Add default value if it exists
  if (itemConfig.defaultValue !== undefined && itemConfig.defaultValue !== null && itemConfig.defaultValue !== '' && itemConfig.defaultValue !== 0) {
    baseProperty.default = itemConfig.defaultValue
  }

  // Handle different item config types using the same logic as portConfigToJsonSchema
  if (isStringPortConfig(itemConfig)) {
    return {
      ...baseProperty,
      type: 'string',
      ...(itemConfig.minLength !== undefined && { minLength: itemConfig.minLength }),
      ...(itemConfig.maxLength !== undefined && { maxLength: itemConfig.maxLength }),
      ...(itemConfig.pattern && { pattern: itemConfig.pattern }),
    }
  }

  if (isNumberPortConfig(itemConfig)) {
    return {
      ...baseProperty,
      type: itemConfig.integer ? 'integer' : 'number',
      ...(itemConfig.min !== undefined && { minimum: itemConfig.min }),
      ...(itemConfig.max !== undefined && { maximum: itemConfig.max }),
      ...(itemConfig.step !== undefined && { multipleOf: itemConfig.step }),
    }
  }

  if (isBooleanPortConfig(itemConfig)) {
    return {
      ...baseProperty,
      type: 'boolean',
    }
  }

  if (isEnumPortConfig(itemConfig)) {
    const enumValues = itemConfig.options
      .map(option => option.id || option.defaultValue)
      .filter((id): id is string => Boolean(id))

    const enumTitles = itemConfig.options
      .map(option => option.title || option.id || option.defaultValue)
      .filter((title): title is string => Boolean(title))

    const res: SchemaProperty = {
      ...baseProperty,
      type: 'string',
    }

    if (enumValues.length > 0) {
      res.enum = enumValues
      res.enumTitles = enumTitles
    }

    return res
  }

  if (isArrayPortConfig(itemConfig)) {
    // Handle nested arrays recursively
    const nestedItemProperty = processItemConfig(itemConfig.itemConfig)

    return {
      ...baseProperty,
      type: 'array',
      items: nestedItemProperty,
      ...(itemConfig.minLength !== undefined && { minItems: itemConfig.minLength }),
      ...(itemConfig.maxLength !== undefined && { maxItems: itemConfig.maxLength }),
    }
  }

  if (isObjectPortConfig(itemConfig)) {
    // Handle nested objects
    const properties: Record<string, SchemaProperty> = {}
    const required: string[] = []

    if (itemConfig.schema?.properties) {
      for (const [key, propConfig] of Object.entries(itemConfig.schema.properties)) {
        properties[key] = processItemConfig(propConfig)
        if (propConfig.required) {
          required.push(key)
        }
      }
    }

    return {
      ...baseProperty,
      type: 'object',
      properties,
      ...(required.length > 0 && { required }),
    }
  }

  if (isAnyPortConfig(itemConfig)) {
    return {
      ...baseProperty,
      type: 'any',
    }
  }

  // Fallback for basic item configs or unknown types
  if (itemConfig.type) {
    return {
      ...baseProperty,
      type: itemConfig.type,
    }
  }

  // Default fallback
  return {
    type: 'string',
    description: 'Array item',
  }
}

/**
 * Processes an object port recursively
 */
export function processObjectPort(
  node: BaseNode,
  port: IPort,
): SchemaProperty {
  const config = port.getConfig()

  if (!isObjectPortConfig(config)) {
    return {
      type: 'object',
      description: config.description || config.title || '',
      properties: {},
    }
  }

  const properties: Record<string, SchemaProperty> = {}
  const required: string[] = []

  // Process each property in the object schema
  if (config.schema?.properties) {
    for (const [key, propConfig] of Object.entries(config.schema.properties)) {
      const originalPort = findPort(node, (p) => {
        return p.getConfig().key === propConfig.key && p.getConfig().parentId === port.id
      })
      if (!originalPort) {
        // If the port is not found, skip it
        continue
      }

      if (isNeedsToSkipPort(node, originalPort)) {
        continue
      }
      // For basic property configs, create schema properties directly
      properties[key] = portConfigToJsonSchema(node, originalPort)

      if (propConfig.required) {
        required.push(key)
      }
    }
  }

  return {
    type: 'object',
    description: config.description || config.title || '',
    properties,
    ...(required.length > 0 && { required }),
  }
}

/**
 * Processes an array port
 */
export function processArrayPort(port: IPort): SchemaProperty {
  const config = port.getConfig()

  if (!isArrayPortConfig(config)) {
    return {
      type: 'array',
      description: config.description || config.title || '',
      items: {
        type: 'string',
      },
    }
  }

  // Process the item configuration
  const itemProperty = processItemConfig(config.itemConfig)

  return {
    type: 'array',
    description: config.description || config.title || '',
    items: itemProperty,
    ...(config.minLength !== undefined && { minItems: config.minLength }),
    ...(config.maxLength !== undefined && { maxItems: config.maxLength }),
  }
}
