/*
 * Copyright (c) 2025 BadLabs
 *
 * Use of this software is governed by the Business Source License 1.1 included in the file LICENSE.txt.
 *
 * As of the Change Date specified in that file, in accordance with the Business Source License, use of this software will be governed by the Apache License, version 2.0.
 */

/* eslint-disable */
import * as types from './graphql';
import { TypedDocumentNode as DocumentNode } from '@graphql-typed-document-node/core';

/**
 * Map of all GraphQL operations in the project.
 *
 * This map has several performance disadvantages:
 * 1. It is not tree-shakeable, so it will include all operations in the project.
 * 2. It is not minifiable, so the string of a GraphQL query will be multiple times inside the bundle.
 * 3. It does not support dead code elimination, so it will add unused operations.
 *
 * Therefore it is highly recommended to use the babel or swc plugin for production.
 * Learn more about it here: https://the-guild.dev/graphql/codegen/plugins/presets/preset-client#reducing-bundle-size
 */
type Documents = {
    "query AdminAgentGetTwitterApiKeys($session: Session!, $agent_id: AgentID!) {\n  adminAgentGetTwitterApiKeys(session: $session, agent_id: $agent_id) {\n    access_token\n    access_token_secret\n    consumer_key\n    consumer_secret\n  }\n}": typeof types.AdminAgentGetTwitterApiKeysDocument,
    "query AdminGetParticipantTelegramBotAPIKey($session: Session!, $chat_id: ChatID!) {\n  adminGetParticipantTelegramBotApiKey(session: $session, chat_id: $chat_id)\n}": typeof types.AdminGetParticipantTelegramBotApiKeyDocument,
    "query chainGraphGet($session: Session!, $chat_id: ChatID!, $participant_id: ParticipantID!) {\n  chainGraphGet(\n    session: $session\n    chat_id: $chat_id\n    participant_id: $participant_id\n  ) {\n    author\n    created_at\n    graph\n    graph_id\n  }\n}": typeof types.ChainGraphGetDocument,
    "query ChatRoomGetParticipant($session: Session!, $chat_id: ChatID!, $participant_id: ParticipantID!) {\n  chatRoomGetParticipant(\n    session: $session\n    chat_id: $chat_id\n    participant_id: $participant_id\n  ) {\n    agent_id\n    avatar\n    first_name\n    is_agent\n    last_name\n    participant_id\n    purpose\n    role\n    self_awareness\n    tools {\n      name\n    }\n    username\n    llm_model\n    meta\n  }\n}": typeof types.ChatRoomGetParticipantDocument,
    "query ChatRoomGetParticipants($session: Session!, $chat_id: ChatID!) {\n  chatRoomGetParticipants(session: $session, chat_id: $chat_id) {\n    agent_id\n    avatar\n    first_name\n    is_agent\n    last_name\n    participant_id\n    purpose\n    role\n    self_awareness\n    tools {\n      name\n    }\n    username\n    llm_model\n    meta\n  }\n}": typeof types.ChatRoomGetParticipantsDocument,
    "query GetChatRoom($session: Session!, $chat_id: ChatID!) {\n  getChatRoom(session: $session, chat_id: $chat_id) {\n    id\n    name\n    author\n    created_at\n    deleted_at\n    deleted\n    updated_at\n    last_message_time\n    last_message {\n      ...MessageFields\n    }\n    participants {\n      participant_id\n      agent_id\n      first_name\n      last_name\n      username\n      avatar\n      is_agent\n      role\n      purpose\n      self_awareness\n      tools {\n        name\n      }\n      llm_model\n      meta\n    }\n    meta\n  }\n}": typeof types.GetChatRoomDocument,
    "query GetChatRooms($session: Session!) {\n  getChatRooms(session: $session) {\n    id\n    name\n    author\n    created_at\n    deleted_at\n    deleted\n    updated_at\n    last_message_time\n    last_message {\n      ...MessageFields\n    }\n    participants {\n      participant_id\n      agent_id\n      first_name\n      last_name\n      username\n      avatar\n      is_agent\n      role\n      purpose\n      self_awareness\n      tools {\n        name\n      }\n      llm_model\n      meta\n    }\n    meta\n  }\n}": typeof types.GetChatRoomsDocument,
    "query GetMessage($session: Session!, $chat_id: ChatID!, $id: MessageID!) {\n  message(session: $session, chat_id: $chat_id, id: $id) {\n    ...MessageFields\n  }\n}": typeof types.GetMessageDocument,
    "query GetMessages($session: Session!, $chat_id: ChatID!, $from: MessageID!, $limit: Int, $order: String) {\n  messages(\n    session: $session\n    chat_id: $chat_id\n    from: $from\n    limit: $limit\n    order: $order\n  ) {\n    ...MessageFields\n  }\n}": typeof types.GetMessagesDocument,
    "query GetMessagesWithoutSystem($session: Session!, $chat_id: ChatID!, $from: MessageID!, $limit: Int, $order: String) {\n  messagesWithoutSystem(\n    session: $session\n    chat_id: $chat_id\n    from: $from\n    limit: $limit\n    order: $order\n  ) {\n    ...MessageFields\n  }\n}": typeof types.GetMessagesWithoutSystemDocument,
    "mutation AddAgentToChat($session: Session!, $chat_id: ChatID!, $agent_id: AgentID!) {\n  addAgentToChat(session: $session, chat_id: $chat_id, agent_id: $agent_id)\n}": typeof types.AddAgentToChatDocument,
    "mutation MessageAddDelta($session: Session!, $chat_id: ChatID!, $message_id: MessageID!, $delta: String!) {\n  addDelta(session: $session, chat_id: $chat_id, id: $message_id, delta: $delta) {\n    id\n    chat_id\n    text\n    version\n  }\n}": typeof types.MessageAddDeltaDocument,
    "mutation AddMessageAttachment($session: Session!, $chat_id: ChatID!, $id: MessageID!, $attachment_id: AttachmentID!) {\n  addMessageAttachment(\n    session: $session\n    chat_id: $chat_id\n    id: $id\n    attachment_id: $attachment_id\n  ) {\n    ...MessageFields\n  }\n}": typeof types.AddMessageAttachmentDocument,
    "mutation ChatRoomCreateParticipant($session: Session!, $chat_id: ChatID!, $input: ParticipantInput!) {\n  chatRoomCreateParticipant(session: $session, chat_id: $chat_id, input: $input) {\n    agent_id\n    avatar\n    first_name\n    is_agent\n    last_name\n    participant_id\n    purpose\n    role\n    self_awareness\n    tools {\n      name\n    }\n    username\n    llm_model\n    meta\n  }\n}": typeof types.ChatRoomCreateParticipantDocument,
    "mutation ChatRoomUpdateParticipant($session: Session!, $chat_id: ChatID!, $participant_id: ParticipantID!, $input: ParticipantInput!) {\n  chatRoomUpdateParticipant(\n    session: $session\n    chat_id: $chat_id\n    participant_id: $participant_id\n    input: $input\n  ) {\n    agent_id\n    avatar\n    first_name\n    is_agent\n    last_name\n    participant_id\n    purpose\n    role\n    self_awareness\n    tools {\n      name\n    }\n    username\n    llm_model\n    meta\n  }\n}": typeof types.ChatRoomUpdateParticipantDocument,
    "mutation CreateChatRoom($session: Session!, $agents: [AgentID!] = []) {\n  createChatRoom(session: $session, agents: $agents) {\n    id\n    name\n    author\n    created_at\n    deleted_at\n    deleted\n    updated_at\n    last_message_time\n    last_message {\n      ...MessageFields\n    }\n    participants {\n      agent_id\n      avatar\n      first_name\n      is_agent\n      last_name\n      participant_id\n      purpose\n      role\n      self_awareness\n      tools {\n        name\n      }\n      username\n      llm_model\n      meta\n    }\n    meta\n  }\n}": typeof types.CreateChatRoomDocument,
    "mutation DeleteChatRoom($session: Session!, $chatID: ChatID!) {\n  deleteChatRoom(session: $session, id: $chatID)\n}": typeof types.DeleteChatRoomDocument,
    "mutation DeleteMessage($session: Session!, $chat_id: ChatID!, $message_id: MessageID!) {\n  deleteMessage(session: $session, chat_id: $chat_id, id: $message_id) {\n    ...MessageFields\n  }\n}": typeof types.DeleteMessageDocument,
    "mutation EditMessage($session: Session!, $chat_id: ChatID!, $id: MessageID!, $message: MessageEditInput!) {\n  editMessage(session: $session, chat_id: $chat_id, id: $id, message: $message) {\n    ...MessageFields\n  }\n}": typeof types.EditMessageDocument,
    "mutation FinishMessage($session: Session!, $chat_id: ChatID!, $id: MessageID!) {\n  finishMessage(session: $session, chat_id: $chat_id, id: $id) {\n    ...MessageFields\n  }\n}": typeof types.FinishMessageDocument,
    "mutation RegenerateLastResponse($session: Session!, $chat_id: ChatID!) {\n  regenerateLastResponse(session: $session, chat_id: $chat_id)\n}": typeof types.RegenerateLastResponseDocument,
    "mutation RenameChatRoom($session: Session!, $id: ChatID!, $new_name: String!) {\n  renameChatRoom(session: $session, id: $id, new_name: $new_name) {\n    id\n    name\n    author\n    created_at\n    deleted_at\n    deleted\n    updated_at\n    last_message_time\n    last_message {\n      ...MessageFields\n    }\n    participants {\n      agent_id\n      avatar\n      first_name\n      is_agent\n      last_name\n      participant_id\n      purpose\n      role\n      self_awareness\n      tools {\n        name\n      }\n      username\n      llm_model\n      meta\n    }\n    meta\n  }\n}": typeof types.RenameChatRoomDocument,
    "mutation SendMessage($session: Session!, $chat_id: ChatID!, $message: MessageInput!) {\n  sendMessage(session: $session, chat_id: $chat_id, message: $message) {\n    ...MessageFields\n  }\n}": typeof types.SendMessageDocument,
    "mutation SetMessageMeta($session: Session!, $chat_id: ChatID!, $id: MessageID!, $message_meta: MessageMetaInput!) {\n  setMessageMeta(\n    session: $session\n    chat_id: $chat_id\n    id: $id\n    message_meta: $message_meta\n  ) {\n    ...MessageFields\n  }\n}": typeof types.SetMessageMetaDocument,
    "mutation StopCompletion($session: Session!, $chat_id: ChatID!) {\n  stopCompletion(session: $session, chat_id: $chat_id)\n}": typeof types.StopCompletionDocument,
    "mutation UnsubscribeMessages($session: Session!, $chat_id: ChatID!, $sub_id: SubscriptionID!) {\n  unsubscribeMessages(session: $session, chat_id: $chat_id, sub_id: $sub_id)\n}": typeof types.UnsubscribeMessagesDocument,
    "query AuthMetamaskMessage($address: MetamaskAddress!) {\n  authMetamaskMessage(address: $address)\n}": typeof types.AuthMetamaskMessageDocument,
    "query GetTweetsFromDB($session: Session!, $tweets_ids: [TweetID!]!) {\n  getTweetsFromDB(session: $session, tweets_ids: $tweets_ids) {\n    ...TweetFields\n  }\n}\n\nfragment TwitterUserFields on TwitterUser {\n  created_at\n  description\n  id\n  name\n  profile_image_url\n  public_metrics {\n    followers_count\n    following_count\n    listed_count\n    tweet_count\n  }\n  url\n  username\n  verified\n}\n\nfragment TweetFields on Tweet {\n  tweet_id\n  text\n  author {\n    ...TwitterUserFields\n  }\n  conversation_id\n  in_reply_to_user_id\n  reply_to_tweet_id\n  created_at\n  mentioned_users {\n    ...TwitterUserFields\n  }\n  public_metrics {\n    like_count\n    quote_count\n    reply_count\n    retweet_count\n  }\n  quoted_tweet {\n    author {\n      ...TwitterUserFields\n    }\n    conversation_id\n    in_reply_to_user_id\n    reply_to_tweet_id\n    created_at\n    mentioned_users {\n      ...TwitterUserFields\n    }\n    public_metrics {\n      like_count\n      quote_count\n      reply_count\n      retweet_count\n    }\n    quoted_tweet {\n      tweet_id\n    }\n    reply_tweet {\n      tweet_id\n    }\n    text\n    tweet_id\n  }\n  reply_tweet {\n    author {\n      ...TwitterUserFields\n    }\n    conversation_id\n    in_reply_to_user_id\n    reply_to_tweet_id\n    created_at\n    mentioned_users {\n      ...TwitterUserFields\n    }\n    public_metrics {\n      like_count\n      quote_count\n      reply_count\n      retweet_count\n    }\n    quoted_tweet {\n      tweet_id\n    }\n    reply_tweet {\n      tweet_id\n    }\n    text\n    tweet_id\n  }\n}": typeof types.GetTweetsFromDbDocument,
    "fragment ChunkFields on Chunk {\n  chunk_id\n  chunk_number\n  content\n  document_id\n  task_id\n  indexing_state {\n    completion_cost\n    completion_tokens\n    content_tokens\n    embedding_cost\n    is_embedded\n    is_indexed_qa\n    is_indexed_triplet\n    is_parsed\n    is_summarized\n    prompt_cost\n    prompt_tokens\n  }\n  page_number_from\n  page_number_to\n}": typeof types.ChunkFieldsFragmentDoc,
    "fragment CollectionFields on Collection {\n  collection_id\n  agent_id\n  creator_address\n  name\n  description\n  created_at\n  indexing_state {\n    completion_cost\n    completion_tokens\n    content_tokens\n    embedding_cost\n    is_embedded\n    is_indexed_qa\n    is_indexed_triplet\n    is_parsed\n    is_summarized\n    prompt_cost\n    prompt_tokens\n  }\n  tags\n}": typeof types.CollectionFieldsFragmentDoc,
    "fragment DocumentFields on DocumentMeta {\n  document_id\n  collection_id\n  url\n  created_at\n  published_at\n  name\n  description\n  tags\n  metadata {\n    key\n    value\n  }\n  indexing_state {\n    completion_cost\n    completion_tokens\n    content_tokens\n    embedding_cost\n    is_embedded\n    is_indexed_qa\n    is_indexed_triplet\n    is_parsed\n    is_summarized\n    prompt_cost\n    prompt_tokens\n  }\n}": typeof types.DocumentFieldsFragmentDoc,
    "query KDBGetParticipantCollections($session: Session!, $agent_id: AgentID!) {\n  kdbGetAgentCollections(session: $session, agent_id: $agent_id) {\n    ...CollectionFields\n  }\n}": typeof types.KdbGetParticipantCollectionsDocument,
    "query KDBGetChunk($session: Session!, $chunk_id: ChunkID!) {\n  kdbGetChunk(session: $session, chunk_id: $chunk_id) {\n    ...ChunkFields\n  }\n}": typeof types.KdbGetChunkDocument,
    "query KDBGetChunksByDocument($session: Session!, $document_id: DocumentID!) {\n  kdbGetChunksByDocument(session: $session, document_id: $document_id) {\n    ...ChunkFields\n  }\n}": typeof types.KdbGetChunksByDocumentDocument,
    "query KDBGetChunksByTask($session: Session!, $task_id: TaskID!) {\n  kdbGetChunksByTask(session: $session, task_id: $task_id) {\n    ...ChunkFields\n  }\n}": typeof types.KdbGetChunksByTaskDocument,
    "query KDBGetCollection($session: Session!, $collection_id: CollectionID!) {\n  kdbGetCollection(session: $session, collection_id: $collection_id) {\n    ...CollectionFields\n  }\n}": typeof types.KdbGetCollectionDocument,
    "query KDBGetDocuments($session: Session!, $document_ids: [DocumentID!]!) {\n  kdbGetDocuments(session: $session, document_ids: $document_ids) {\n    ...DocumentFields\n  }\n}": typeof types.KdbGetDocumentsDocument,
    "query KDBGetDocumentsByCollection($session: Session!, $collection_id: CollectionID!, $filters: GetDocumentsByCollectionFilters = {published_range: {}}, $order_by: GetDocumentsByCollectionOrderByInput!, $limit: Int = 1000) {\n  kdbGetDocumentsByCollection(\n    session: $session\n    collection_id: $collection_id\n    filters: $filters\n    order_by: $order_by\n    limit: $limit\n  ) {\n    document {\n      ...DocumentFields\n    }\n    pagesCount\n  }\n}": typeof types.KdbGetDocumentsByCollectionDocument,
    "query KDBGetPagesByDocument($session: Session!, $document_id: DocumentID!, $filters: GetPagesByDocumentFilters = {}) {\n  kdbGetPagesByDocument(\n    session: $session\n    document_id: $document_id\n    filters: $filters\n  ) {\n    page_id\n    content\n    description\n    document_id\n    task_id\n    number\n  }\n}": typeof types.KdbGetPagesByDocumentDocument,
    "query KDBGetPagesByTask($session: Session!, $task_id: TaskID!) {\n  kdbGetPagesByTask(session: $session, task_id: $task_id) {\n    ...PageFields\n  }\n}": typeof types.KdbGetPagesByTaskDocument,
    "fragment IndexingDocumentTaskFields on IndexingDocumentTask {\n  task_id\n  document_id\n  chat_id\n  message_id\n  author_id\n  task_state\n  created_at\n  update_at\n  confirmed\n  version\n  error\n  statistics {\n    chunks_indexed_qa\n    chunks_indexed_triplet\n    chunks_total\n    current_indexing_speed\n    expected_finish_seconds\n    expected_finished_at\n    indexed_percent\n    indexing_started_at\n    llm_approximate_cost\n    llm_stats {\n      completion_cost\n      embeddings_cost\n      embeddings_count\n      prompt_cost\n      total_cost\n    }\n    pages\n    qa_total\n    total_tokens\n    triplets_total\n    indexed_for_seconds\n  }\n  config {\n    chunk_overlap_tokens\n    chunk_size_tokens\n    cost_limit\n    need_qa\n    qa_count_per_run\n    qa_model\n    force_confirm\n    instruction_for_qa\n  }\n}": typeof types.IndexingDocumentTaskFieldsFragmentDoc,
    "query KDBIndexingDocumentTaskGet($session: Session!, $taskID: TaskID!) {\n  kdbIndexingDocumentTaskGet(session: $session, taskID: $taskID) {\n    ...IndexingDocumentTaskFields\n  }\n}": typeof types.KdbIndexingDocumentTaskGetDocument,
    "query kdbIndexingDocumentTaskGetByCollection($session: Session!, $collections: [CollectionID!]!, $states: [IndexingDocumentTaskState!] = []) {\n  kdbIndexingDocumentTaskGetByCollection(\n    session: $session\n    collection_id: $collections\n    state: $states\n  ) {\n    ...IndexingDocumentTaskFields\n  }\n}": typeof types.KdbIndexingDocumentTaskGetByCollectionDocument,
    "query kdbIndexingDocumentTaskGetByDocument($session: Session!, $document_id: [DocumentID!]!, $state: [IndexingDocumentTaskState!] = []) {\n  kdbIndexingDocumentTaskGetByDocument(\n    session: $session\n    document_id: $document_id\n    state: $state\n  ) {\n    ...IndexingDocumentTaskFields\n  }\n}": typeof types.KdbIndexingDocumentTaskGetByDocumentDocument,
    "query KDBIndexingDocumentTaskGetByState($session: Session!, $state: [IndexingDocumentTaskState!]!, $limit: Int! = 100) {\n  kdbIndexingDocumentTaskGetByState(\n    session: $session\n    state: $state\n    limit: $limit\n  ) {\n    ...IndexingDocumentTaskFields\n  }\n}": typeof types.KdbIndexingDocumentTaskGetByStateDocument,
    "fragment PageFields on Page {\n  page_id\n  content\n  description\n  document_id\n  task_id\n  indexing_state {\n    completion_cost\n    completion_tokens\n    content_tokens\n    embedding_cost\n    is_embedded\n    is_indexed_qa\n    is_indexed_triplet\n    is_parsed\n    is_summarized\n    prompt_cost\n    prompt_tokens\n  }\n  number\n}": typeof types.PageFieldsFragmentDoc,
    "fragment QaFields on QA {\n  answer\n  answer_tokens\n  chunk_id\n  chunk_number\n  created_at\n  document_id\n  document_published_at\n  indexing_state {\n    completion_cost\n    completion_tokens\n    content_tokens\n    embedding_cost\n    is_embedded\n    is_indexed_qa\n    is_indexed_triplet\n    is_parsed\n    is_summarized\n    prompt_cost\n    prompt_tokens\n  }\n  model\n  page_number_from\n  page_number_to\n  qa_id\n  question\n  question_tokens\n  task_id\n}\n\nfragment QaWithDistanceFields on QAWithDistance {\n  qa {\n    ...QaFields\n  }\n  distance\n}\n\nfragment QAWithDocumentsFields on QAWithDocuments {\n  document {\n    ...DocumentFields\n  }\n  qas {\n    ...QaWithDistanceFields\n  }\n}": typeof types.QaFieldsFragmentDoc,
    "query KDBQueryCollectionQA($session: Session!, $collection_id: [CollectionID!]!, $queryString: String!, $threshold: Float! = 0.5, $limit: Int! = 20, $tokensLimit: Int! = 4000) {\n  kdbQueryCollectionQA(\n    session: $session\n    collection_id: $collection_id\n    queryString: $queryString\n    threshold: $threshold\n    limit: $limit\n    tokensLimit: $tokensLimit\n  ) {\n    ...QaWithDistanceFields\n  }\n}": typeof types.KdbQueryCollectionQaDocument,
    "query kdbQueryCollectionQAWithDocuments($session: Session!, $collection_id: [CollectionID!]!, $queryString: String!, $threshold: Float! = 0.5, $limit: Int! = 20, $tokensLimit: Int! = 4000) {\n  kdbQueryCollectionQAWithDocuments(\n    session: $session\n    collection_id: $collection_id\n    queryString: $queryString\n    threshold: $threshold\n    limit: $limit\n    tokensLimit: $tokensLimit\n  ) {\n    ...QAWithDocumentsFields\n  }\n}": typeof types.KdbQueryCollectionQaWithDocumentsDocument,
    "query KDBQueryParticipantCollectionQA($session: Session!, $participantID: ParticipantID!, $queryString: String!, $threshold: Float! = 0.5, $limit: Int! = 20, $tokensLimit: Int! = 4000) {\n  kdbQueryParticipantCollectionQA(\n    session: $session\n    participantID: $participantID\n    queryString: $queryString\n    threshold: $threshold\n    limit: $limit\n    tokensLimit: $tokensLimit\n  ) {\n    ...QaWithDistanceFields\n  }\n}": typeof types.KdbQueryParticipantCollectionQaDocument,
    "query kdbSearchQAWithDocuments($session: Session!, $collections: [CollectionID!]!, $queries: [String!]!, $queries_weights: [Float!], $options: SearchQAOptions, $filters: SearchQAFilters, $order_by: SearchQAOrderBy) {\n  kdbSearchQAWithDocuments(\n    session: $session\n    collections: $collections\n    queries: $queries\n    queries_weights: $queries_weights\n    options: $options\n    filters: $filters\n    order_by: $order_by\n  ) {\n    document {\n      ...DocumentFields\n    }\n    qas {\n      qa {\n        answer\n        answer_tokens\n        chunk_id\n        chunk_number\n        created_at\n        document_id\n        document_published_at\n        indexing_state {\n          completion_cost\n          completion_tokens\n          content_tokens\n          embedding_cost\n          is_embedded\n          is_indexed_qa\n          is_indexed_triplet\n          is_parsed\n          is_summarized\n          prompt_cost\n          prompt_tokens\n        }\n        model\n        page_number_from\n        page_number_to\n        qa_id\n        question\n        question_tokens\n        task_id\n      }\n      similarity\n    }\n  }\n}": typeof types.KdbSearchQaWithDocumentsDocument,
    "mutation KDBCreateChunk($session: Session!, $chunks: [ChunkInput!]!) {\n  kdbCreateChunk(session: $session, chunks: $chunks) {\n    ...ChunkFields\n  }\n}": typeof types.KdbCreateChunkDocument,
    "mutation KDBCreateCollection($session: Session!, $input: CreateAgentCollectionInput!) {\n  kdbCreateAgentCollection(session: $session, input: $input) {\n    collection_id\n  }\n}": typeof types.KdbCreateCollectionDocument,
    "mutation KDBCreateDocument($session: Session!, $doc: DocumentMetaInput!) {\n  kdbCreateDocument(session: $session, doc: $doc) {\n    document_id\n    collection_id\n    url\n    created_at\n    published_at\n    name\n    description\n    tags\n    metadata {\n      key\n      value\n    }\n    indexing_state {\n      completion_cost\n      completion_tokens\n      content_tokens\n      embedding_cost\n      is_embedded\n      is_indexed_qa\n      is_indexed_triplet\n      is_parsed\n      is_summarized\n      prompt_cost\n      prompt_tokens\n    }\n  }\n}": typeof types.KdbCreateDocumentDocument,
    "mutation KDBCreatePage($session: Session!, $pages: [PageInput!]!) {\n  kdbCreatePage(session: $session, pages: $pages) {\n    page_id\n    content\n    description\n    document_id\n    task_id\n    indexing_state {\n      completion_cost\n      completion_tokens\n      content_tokens\n      embedding_cost\n      is_embedded\n      is_indexed_qa\n      is_indexed_triplet\n      is_parsed\n      is_summarized\n      prompt_cost\n      prompt_tokens\n    }\n    number\n  }\n}": typeof types.KdbCreatePageDocument,
    "mutation KDBCreateQA($session: Session!, $qa: CreateQAInput!) {\n  kdbCreateQA(session: $session, qa: $qa) {\n    ...QaFields\n  }\n}": typeof types.KdbCreateQaDocument,
    "mutation KDBCreateTriplet($session: Session!, $triplets: CreateTripletInput!) {\n  kdbCreateTriplet(session: $session, triplet: $triplets) {\n    chunk_id\n    document_id\n    task_id\n    object\n    predicate\n    subject\n    triplet_id\n    indexing_state {\n      completion_cost\n      completion_tokens\n      content_tokens\n      embedding_cost\n      is_embedded\n      is_indexed_qa\n      is_indexed_triplet\n      is_parsed\n      is_summarized\n      prompt_cost\n      prompt_tokens\n    }\n  }\n}": typeof types.KdbCreateTripletDocument,
    "mutation KDBIndexingDocumentTaskCreate($session: Session!, $input: KdbIndexingDocumentTaskCreateInput!) {\n  kdbIndexingDocumentTaskCreate(session: $session, input: $input) {\n    task_id\n    document_id\n    chat_id\n    message_id\n    author_id\n    task_state\n    created_at\n    update_at\n    confirmed\n    version\n    error\n    statistics {\n      chunks_indexed_qa\n      chunks_indexed_triplet\n      chunks_total\n      current_indexing_speed\n      expected_finish_seconds\n      expected_finished_at\n      indexed_percent\n      indexing_started_at\n      llm_approximate_cost\n      llm_stats {\n        completion_cost\n        embeddings_cost\n        embeddings_count\n        prompt_cost\n        total_cost\n      }\n      pages\n      qa_total\n      total_tokens\n      triplets_total\n      indexed_for_seconds\n    }\n    config {\n      chunk_overlap_tokens\n      chunk_size_tokens\n      cost_limit\n      need_qa\n      qa_count_per_run\n      qa_model\n      force_confirm\n      instruction_for_qa\n    }\n  }\n}": typeof types.KdbIndexingDocumentTaskCreateDocument,
    "mutation KDBIndexingDocumentTaskError($session: Session!, $taskID: TaskID!, $version: Int!, $error: String!) {\n  kdbIndexingDocumentTaskError(\n    session: $session\n    taskID: $taskID\n    version: $version\n    error: $error\n  ) {\n    ...IndexingDocumentTaskFields\n  }\n}": typeof types.KdbIndexingDocumentTaskErrorDocument,
    "mutation KDBIndexingDocumentTaskTransitionState($session: Session!, $taskID: TaskID!, $toState: IndexingDocumentTaskState!, $version: Int!) {\n  kdbIndexingDocumentTaskTransitionState(\n    session: $session\n    taskID: $taskID\n    toState: $toState\n    version: $version\n  ) {\n    ...IndexingDocumentTaskFields\n  }\n}": typeof types.KdbIndexingDocumentTaskTransitionStateDocument,
    "query MarketplaceAgent($session: Session!, $agent_id: AgentID!) {\n  marketplaceAgent(session: $session, agent_id: $agent_id) {\n    agent_id\n    username\n    first_name\n    last_name\n    avatar\n    role\n    can_answer\n    owner_id\n    chain_graph_id\n    llm_config {\n      model\n      max_tokens\n      temperature\n    }\n    template_params\n    purpose\n    prompt\n    self_awareness\n    tools {\n      name\n    }\n    llm_model\n    chat_history_config {\n      messages_count\n      tokens_limit\n    }\n  }\n}": typeof types.MarketplaceAgentDocument,
    "fragment agentFields on AgentMeta {\n  agent_id\n  username\n  owner_id\n  first_name\n  last_name\n  avatar\n  role\n  can_answer\n  chain_graph_id\n  skeleton\n  template_params\n  llm_config {\n    model\n    temperature\n    max_tokens\n  }\n  is_agent\n  deployment_status\n  prompt\n  chat_history_config {\n    messages_count\n    tokens_limit\n  }\n  llm_model\n  purpose\n  self_awareness\n  tools {\n    name\n  }\n}\n\nfragment agentCollectionFields on AgentCollection {\n  collection_id\n  title\n  description\n  owner_id\n  order\n  updated_at\n  agents {\n    ...agentFields\n  }\n}\n\nquery MarketplaceAgents($session: Session!) {\n  marketplaceAgents(session: $session) {\n    ...agentCollectionFields\n  }\n}": typeof types.AgentFieldsFragmentDoc,
    "fragment MessageFields on Message {\n  attachments {\n    filename\n    id\n    mime_type\n    size\n    url\n  }\n  author\n  chat_id\n  deleted\n  error\n  finished\n  id\n  is_system\n  meta\n  need_answer\n  participant {\n    agent_id\n    avatar\n    first_name\n    is_agent\n    last_name\n    llm_model\n    meta\n    participant_id\n    purpose\n    role\n    self_awareness\n    tools {\n      name\n    }\n    username\n  }\n  reply_to\n  text\n  time\n  total_usage_cost\n  type\n  version\n  signals {\n    message_id\n    ... on AgentTriggeredSignal {\n      message_id\n      agent_id\n    }\n  }\n}": typeof types.MessageFieldsFragmentDoc,
    "mutation AuthAgentLogin($agentID: AgentID!, $session: Session!) {\n  authAgentLogin(agentID: $agentID, session: $session) {\n    session\n    user_profile {\n      id\n      name\n      picture\n    }\n  }\n}": typeof types.AuthAgentLoginDocument,
    "mutation AppendUsages($session: Session!, $usages: [UsageInput!]!) {\n  appendUsages(session: $session, usages: $usages)\n}": typeof types.AppendUsagesDocument,
    "mutation AuthMetamaskLogin($input: MetamaskLoginInput!) {\n  authMetamaskLogin(input: $input) {\n    session\n    user_profile {\n      id\n      name\n      picture\n    }\n  }\n}": typeof types.AuthMetamaskLoginDocument,
    "mutation UploadAttachment($session: Session!, $attachment: AttachmentBlob!) {\n  uploadAttachment(session: $session, attachment: $attachment) {\n    id\n    mime_type\n    url\n  }\n}": typeof types.UploadAttachmentDocument,
    "mutation VoiceToText($session: Session!, $attachment_id: AttachmentID!) {\n  voiceToText(session: $session, attachment_id: $attachment_id) {\n    language\n    tokens\n    text\n    avg_logprob\n    no_speech_prob\n    temperature\n    compression_ratio\n  }\n}": typeof types.VoiceToTextDocument,
    "subscription SubscribeChatRooms($session: Session!, $limit_chats: Int) {\n  subscribeChatRooms(session: $session, limit_chats: $limit_chats) {\n    sub_id\n    event\n    chat_rooms {\n      id\n      name\n      author\n      created_at\n      deleted_at\n      deleted\n      participants {\n        participant_id\n        agent_id\n        first_name\n        last_name\n        username\n        avatar\n        is_agent\n        role\n        purpose\n        self_awareness\n        tools {\n          name\n        }\n        llm_model\n        meta\n      }\n      meta\n    }\n    participants {\n      participant_id\n      agent_id\n      avatar\n      first_name\n      is_agent\n      last_name\n      purpose\n      role\n      self_awareness\n      username\n      tools {\n        name\n      }\n      llm_model\n      meta\n    }\n  }\n}": typeof types.SubscribeChatRoomsDocument,
    "subscription SubscribeMessages($session: Session!, $chat_id: ChatID!, $limitMessages: Int! = 100) {\n  subscribeMessages(\n    session: $session\n    chat_id: $chat_id\n    limitMessages: $limitMessages\n  ) {\n    event\n    sub_id\n    message {\n      ...MessageFields\n    }\n    messages {\n      ...MessageFields\n    }\n  }\n}": typeof types.SubscribeMessagesDocument,
    "query GetUserProfile($session: Session!) {\n  userProfile(session: $session) {\n    email\n    externalAccounts {\n      ID\n      providerID\n    }\n    id\n    name\n    picture\n    role\n    tariffCurrent\n    tariffExpires\n  }\n}": typeof types.GetUserProfileDocument,
    "fragment variableFields on Variable {\n  id\n  namespace\n  key\n  value {\n    type\n    value\n  }\n  createdAt\n  updatedAt\n}\n\nquery GetVariable($session: Session!, $namespace: NamespaceInput!, $key: String!) {\n  getVariable(session: $session, namespace: $namespace, key: $key) {\n    variable {\n      ...variableFields\n    }\n  }\n}\n\nquery GetVariables($session: Session!, $namespace: NamespaceInput!) {\n  getVariables(session: $session, namespace: $namespace) {\n    variables {\n      ...variableFields\n    }\n  }\n}\n\nmutation SetVariable($session: Session!, $namespace: NamespaceInput!, $key: String!, $value: VariableValueInput!) {\n  setVariable(session: $session, namespace: $namespace, key: $key, value: $value) {\n    variable {\n      ...variableFields\n    }\n  }\n}\n\nmutation SetVariables($session: Session!, $namespace: NamespaceInput!, $variables: [KeyValueInput!]!) {\n  setVariables(session: $session, namespace: $namespace, variables: $variables) {\n    variables {\n      ...variableFields\n    }\n  }\n}\n\nmutation DeleteVariable($session: Session!, $namespace: NamespaceInput!, $key: String!) {\n  deleteVariable(session: $session, namespace: $namespace, key: $key)\n}\n\nmutation DeleteVariables($session: Session!, $namespace: NamespaceInput!) {\n  deleteVariables(session: $session, namespace: $namespace)\n}\n\nmutation AppendVariable($session: Session!, $namespace: NamespaceInput!, $key: String!, $value: VariableValueInput!) {\n  appendVariable(\n    session: $session\n    namespace: $namespace\n    key: $key\n    value: $value\n  ) {\n    variable {\n      ...variableFields\n    }\n  }\n}": typeof types.VariableFieldsFragmentDoc,
    "query ReadSecret($session: Session!, $id: SecretID!, $publicKey: ECDHPublicKeyP256!) {\n  secret(session: $session, id: $id, publicKey: $publicKey) {\n    hkdfNonce\n    publicKey\n    secret {\n      encrypted\n      metadata {\n        type\n      }\n    }\n  }\n}": typeof types.ReadSecretDocument,
};
const documents: Documents = {
    "query AdminAgentGetTwitterApiKeys($session: Session!, $agent_id: AgentID!) {\n  adminAgentGetTwitterApiKeys(session: $session, agent_id: $agent_id) {\n    access_token\n    access_token_secret\n    consumer_key\n    consumer_secret\n  }\n}": types.AdminAgentGetTwitterApiKeysDocument,
    "query AdminGetParticipantTelegramBotAPIKey($session: Session!, $chat_id: ChatID!) {\n  adminGetParticipantTelegramBotApiKey(session: $session, chat_id: $chat_id)\n}": types.AdminGetParticipantTelegramBotApiKeyDocument,
    "query chainGraphGet($session: Session!, $chat_id: ChatID!, $participant_id: ParticipantID!) {\n  chainGraphGet(\n    session: $session\n    chat_id: $chat_id\n    participant_id: $participant_id\n  ) {\n    author\n    created_at\n    graph\n    graph_id\n  }\n}": types.ChainGraphGetDocument,
    "query ChatRoomGetParticipant($session: Session!, $chat_id: ChatID!, $participant_id: ParticipantID!) {\n  chatRoomGetParticipant(\n    session: $session\n    chat_id: $chat_id\n    participant_id: $participant_id\n  ) {\n    agent_id\n    avatar\n    first_name\n    is_agent\n    last_name\n    participant_id\n    purpose\n    role\n    self_awareness\n    tools {\n      name\n    }\n    username\n    llm_model\n    meta\n  }\n}": types.ChatRoomGetParticipantDocument,
    "query ChatRoomGetParticipants($session: Session!, $chat_id: ChatID!) {\n  chatRoomGetParticipants(session: $session, chat_id: $chat_id) {\n    agent_id\n    avatar\n    first_name\n    is_agent\n    last_name\n    participant_id\n    purpose\n    role\n    self_awareness\n    tools {\n      name\n    }\n    username\n    llm_model\n    meta\n  }\n}": types.ChatRoomGetParticipantsDocument,
    "query GetChatRoom($session: Session!, $chat_id: ChatID!) {\n  getChatRoom(session: $session, chat_id: $chat_id) {\n    id\n    name\n    author\n    created_at\n    deleted_at\n    deleted\n    updated_at\n    last_message_time\n    last_message {\n      ...MessageFields\n    }\n    participants {\n      participant_id\n      agent_id\n      first_name\n      last_name\n      username\n      avatar\n      is_agent\n      role\n      purpose\n      self_awareness\n      tools {\n        name\n      }\n      llm_model\n      meta\n    }\n    meta\n  }\n}": types.GetChatRoomDocument,
    "query GetChatRooms($session: Session!) {\n  getChatRooms(session: $session) {\n    id\n    name\n    author\n    created_at\n    deleted_at\n    deleted\n    updated_at\n    last_message_time\n    last_message {\n      ...MessageFields\n    }\n    participants {\n      participant_id\n      agent_id\n      first_name\n      last_name\n      username\n      avatar\n      is_agent\n      role\n      purpose\n      self_awareness\n      tools {\n        name\n      }\n      llm_model\n      meta\n    }\n    meta\n  }\n}": types.GetChatRoomsDocument,
    "query GetMessage($session: Session!, $chat_id: ChatID!, $id: MessageID!) {\n  message(session: $session, chat_id: $chat_id, id: $id) {\n    ...MessageFields\n  }\n}": types.GetMessageDocument,
    "query GetMessages($session: Session!, $chat_id: ChatID!, $from: MessageID!, $limit: Int, $order: String) {\n  messages(\n    session: $session\n    chat_id: $chat_id\n    from: $from\n    limit: $limit\n    order: $order\n  ) {\n    ...MessageFields\n  }\n}": types.GetMessagesDocument,
    "query GetMessagesWithoutSystem($session: Session!, $chat_id: ChatID!, $from: MessageID!, $limit: Int, $order: String) {\n  messagesWithoutSystem(\n    session: $session\n    chat_id: $chat_id\n    from: $from\n    limit: $limit\n    order: $order\n  ) {\n    ...MessageFields\n  }\n}": types.GetMessagesWithoutSystemDocument,
    "mutation AddAgentToChat($session: Session!, $chat_id: ChatID!, $agent_id: AgentID!) {\n  addAgentToChat(session: $session, chat_id: $chat_id, agent_id: $agent_id)\n}": types.AddAgentToChatDocument,
    "mutation MessageAddDelta($session: Session!, $chat_id: ChatID!, $message_id: MessageID!, $delta: String!) {\n  addDelta(session: $session, chat_id: $chat_id, id: $message_id, delta: $delta) {\n    id\n    chat_id\n    text\n    version\n  }\n}": types.MessageAddDeltaDocument,
    "mutation AddMessageAttachment($session: Session!, $chat_id: ChatID!, $id: MessageID!, $attachment_id: AttachmentID!) {\n  addMessageAttachment(\n    session: $session\n    chat_id: $chat_id\n    id: $id\n    attachment_id: $attachment_id\n  ) {\n    ...MessageFields\n  }\n}": types.AddMessageAttachmentDocument,
    "mutation ChatRoomCreateParticipant($session: Session!, $chat_id: ChatID!, $input: ParticipantInput!) {\n  chatRoomCreateParticipant(session: $session, chat_id: $chat_id, input: $input) {\n    agent_id\n    avatar\n    first_name\n    is_agent\n    last_name\n    participant_id\n    purpose\n    role\n    self_awareness\n    tools {\n      name\n    }\n    username\n    llm_model\n    meta\n  }\n}": types.ChatRoomCreateParticipantDocument,
    "mutation ChatRoomUpdateParticipant($session: Session!, $chat_id: ChatID!, $participant_id: ParticipantID!, $input: ParticipantInput!) {\n  chatRoomUpdateParticipant(\n    session: $session\n    chat_id: $chat_id\n    participant_id: $participant_id\n    input: $input\n  ) {\n    agent_id\n    avatar\n    first_name\n    is_agent\n    last_name\n    participant_id\n    purpose\n    role\n    self_awareness\n    tools {\n      name\n    }\n    username\n    llm_model\n    meta\n  }\n}": types.ChatRoomUpdateParticipantDocument,
    "mutation CreateChatRoom($session: Session!, $agents: [AgentID!] = []) {\n  createChatRoom(session: $session, agents: $agents) {\n    id\n    name\n    author\n    created_at\n    deleted_at\n    deleted\n    updated_at\n    last_message_time\n    last_message {\n      ...MessageFields\n    }\n    participants {\n      agent_id\n      avatar\n      first_name\n      is_agent\n      last_name\n      participant_id\n      purpose\n      role\n      self_awareness\n      tools {\n        name\n      }\n      username\n      llm_model\n      meta\n    }\n    meta\n  }\n}": types.CreateChatRoomDocument,
    "mutation DeleteChatRoom($session: Session!, $chatID: ChatID!) {\n  deleteChatRoom(session: $session, id: $chatID)\n}": types.DeleteChatRoomDocument,
    "mutation DeleteMessage($session: Session!, $chat_id: ChatID!, $message_id: MessageID!) {\n  deleteMessage(session: $session, chat_id: $chat_id, id: $message_id) {\n    ...MessageFields\n  }\n}": types.DeleteMessageDocument,
    "mutation EditMessage($session: Session!, $chat_id: ChatID!, $id: MessageID!, $message: MessageEditInput!) {\n  editMessage(session: $session, chat_id: $chat_id, id: $id, message: $message) {\n    ...MessageFields\n  }\n}": types.EditMessageDocument,
    "mutation FinishMessage($session: Session!, $chat_id: ChatID!, $id: MessageID!) {\n  finishMessage(session: $session, chat_id: $chat_id, id: $id) {\n    ...MessageFields\n  }\n}": types.FinishMessageDocument,
    "mutation RegenerateLastResponse($session: Session!, $chat_id: ChatID!) {\n  regenerateLastResponse(session: $session, chat_id: $chat_id)\n}": types.RegenerateLastResponseDocument,
    "mutation RenameChatRoom($session: Session!, $id: ChatID!, $new_name: String!) {\n  renameChatRoom(session: $session, id: $id, new_name: $new_name) {\n    id\n    name\n    author\n    created_at\n    deleted_at\n    deleted\n    updated_at\n    last_message_time\n    last_message {\n      ...MessageFields\n    }\n    participants {\n      agent_id\n      avatar\n      first_name\n      is_agent\n      last_name\n      participant_id\n      purpose\n      role\n      self_awareness\n      tools {\n        name\n      }\n      username\n      llm_model\n      meta\n    }\n    meta\n  }\n}": types.RenameChatRoomDocument,
    "mutation SendMessage($session: Session!, $chat_id: ChatID!, $message: MessageInput!) {\n  sendMessage(session: $session, chat_id: $chat_id, message: $message) {\n    ...MessageFields\n  }\n}": types.SendMessageDocument,
    "mutation SetMessageMeta($session: Session!, $chat_id: ChatID!, $id: MessageID!, $message_meta: MessageMetaInput!) {\n  setMessageMeta(\n    session: $session\n    chat_id: $chat_id\n    id: $id\n    message_meta: $message_meta\n  ) {\n    ...MessageFields\n  }\n}": types.SetMessageMetaDocument,
    "mutation StopCompletion($session: Session!, $chat_id: ChatID!) {\n  stopCompletion(session: $session, chat_id: $chat_id)\n}": types.StopCompletionDocument,
    "mutation UnsubscribeMessages($session: Session!, $chat_id: ChatID!, $sub_id: SubscriptionID!) {\n  unsubscribeMessages(session: $session, chat_id: $chat_id, sub_id: $sub_id)\n}": types.UnsubscribeMessagesDocument,
    "query AuthMetamaskMessage($address: MetamaskAddress!) {\n  authMetamaskMessage(address: $address)\n}": types.AuthMetamaskMessageDocument,
    "query GetTweetsFromDB($session: Session!, $tweets_ids: [TweetID!]!) {\n  getTweetsFromDB(session: $session, tweets_ids: $tweets_ids) {\n    ...TweetFields\n  }\n}\n\nfragment TwitterUserFields on TwitterUser {\n  created_at\n  description\n  id\n  name\n  profile_image_url\n  public_metrics {\n    followers_count\n    following_count\n    listed_count\n    tweet_count\n  }\n  url\n  username\n  verified\n}\n\nfragment TweetFields on Tweet {\n  tweet_id\n  text\n  author {\n    ...TwitterUserFields\n  }\n  conversation_id\n  in_reply_to_user_id\n  reply_to_tweet_id\n  created_at\n  mentioned_users {\n    ...TwitterUserFields\n  }\n  public_metrics {\n    like_count\n    quote_count\n    reply_count\n    retweet_count\n  }\n  quoted_tweet {\n    author {\n      ...TwitterUserFields\n    }\n    conversation_id\n    in_reply_to_user_id\n    reply_to_tweet_id\n    created_at\n    mentioned_users {\n      ...TwitterUserFields\n    }\n    public_metrics {\n      like_count\n      quote_count\n      reply_count\n      retweet_count\n    }\n    quoted_tweet {\n      tweet_id\n    }\n    reply_tweet {\n      tweet_id\n    }\n    text\n    tweet_id\n  }\n  reply_tweet {\n    author {\n      ...TwitterUserFields\n    }\n    conversation_id\n    in_reply_to_user_id\n    reply_to_tweet_id\n    created_at\n    mentioned_users {\n      ...TwitterUserFields\n    }\n    public_metrics {\n      like_count\n      quote_count\n      reply_count\n      retweet_count\n    }\n    quoted_tweet {\n      tweet_id\n    }\n    reply_tweet {\n      tweet_id\n    }\n    text\n    tweet_id\n  }\n}": types.GetTweetsFromDbDocument,
    "fragment ChunkFields on Chunk {\n  chunk_id\n  chunk_number\n  content\n  document_id\n  task_id\n  indexing_state {\n    completion_cost\n    completion_tokens\n    content_tokens\n    embedding_cost\n    is_embedded\n    is_indexed_qa\n    is_indexed_triplet\n    is_parsed\n    is_summarized\n    prompt_cost\n    prompt_tokens\n  }\n  page_number_from\n  page_number_to\n}": types.ChunkFieldsFragmentDoc,
    "fragment CollectionFields on Collection {\n  collection_id\n  agent_id\n  creator_address\n  name\n  description\n  created_at\n  indexing_state {\n    completion_cost\n    completion_tokens\n    content_tokens\n    embedding_cost\n    is_embedded\n    is_indexed_qa\n    is_indexed_triplet\n    is_parsed\n    is_summarized\n    prompt_cost\n    prompt_tokens\n  }\n  tags\n}": types.CollectionFieldsFragmentDoc,
    "fragment DocumentFields on DocumentMeta {\n  document_id\n  collection_id\n  url\n  created_at\n  published_at\n  name\n  description\n  tags\n  metadata {\n    key\n    value\n  }\n  indexing_state {\n    completion_cost\n    completion_tokens\n    content_tokens\n    embedding_cost\n    is_embedded\n    is_indexed_qa\n    is_indexed_triplet\n    is_parsed\n    is_summarized\n    prompt_cost\n    prompt_tokens\n  }\n}": types.DocumentFieldsFragmentDoc,
    "query KDBGetParticipantCollections($session: Session!, $agent_id: AgentID!) {\n  kdbGetAgentCollections(session: $session, agent_id: $agent_id) {\n    ...CollectionFields\n  }\n}": types.KdbGetParticipantCollectionsDocument,
    "query KDBGetChunk($session: Session!, $chunk_id: ChunkID!) {\n  kdbGetChunk(session: $session, chunk_id: $chunk_id) {\n    ...ChunkFields\n  }\n}": types.KdbGetChunkDocument,
    "query KDBGetChunksByDocument($session: Session!, $document_id: DocumentID!) {\n  kdbGetChunksByDocument(session: $session, document_id: $document_id) {\n    ...ChunkFields\n  }\n}": types.KdbGetChunksByDocumentDocument,
    "query KDBGetChunksByTask($session: Session!, $task_id: TaskID!) {\n  kdbGetChunksByTask(session: $session, task_id: $task_id) {\n    ...ChunkFields\n  }\n}": types.KdbGetChunksByTaskDocument,
    "query KDBGetCollection($session: Session!, $collection_id: CollectionID!) {\n  kdbGetCollection(session: $session, collection_id: $collection_id) {\n    ...CollectionFields\n  }\n}": types.KdbGetCollectionDocument,
    "query KDBGetDocuments($session: Session!, $document_ids: [DocumentID!]!) {\n  kdbGetDocuments(session: $session, document_ids: $document_ids) {\n    ...DocumentFields\n  }\n}": types.KdbGetDocumentsDocument,
    "query KDBGetDocumentsByCollection($session: Session!, $collection_id: CollectionID!, $filters: GetDocumentsByCollectionFilters = {published_range: {}}, $order_by: GetDocumentsByCollectionOrderByInput!, $limit: Int = 1000) {\n  kdbGetDocumentsByCollection(\n    session: $session\n    collection_id: $collection_id\n    filters: $filters\n    order_by: $order_by\n    limit: $limit\n  ) {\n    document {\n      ...DocumentFields\n    }\n    pagesCount\n  }\n}": types.KdbGetDocumentsByCollectionDocument,
    "query KDBGetPagesByDocument($session: Session!, $document_id: DocumentID!, $filters: GetPagesByDocumentFilters = {}) {\n  kdbGetPagesByDocument(\n    session: $session\n    document_id: $document_id\n    filters: $filters\n  ) {\n    page_id\n    content\n    description\n    document_id\n    task_id\n    number\n  }\n}": types.KdbGetPagesByDocumentDocument,
    "query KDBGetPagesByTask($session: Session!, $task_id: TaskID!) {\n  kdbGetPagesByTask(session: $session, task_id: $task_id) {\n    ...PageFields\n  }\n}": types.KdbGetPagesByTaskDocument,
    "fragment IndexingDocumentTaskFields on IndexingDocumentTask {\n  task_id\n  document_id\n  chat_id\n  message_id\n  author_id\n  task_state\n  created_at\n  update_at\n  confirmed\n  version\n  error\n  statistics {\n    chunks_indexed_qa\n    chunks_indexed_triplet\n    chunks_total\n    current_indexing_speed\n    expected_finish_seconds\n    expected_finished_at\n    indexed_percent\n    indexing_started_at\n    llm_approximate_cost\n    llm_stats {\n      completion_cost\n      embeddings_cost\n      embeddings_count\n      prompt_cost\n      total_cost\n    }\n    pages\n    qa_total\n    total_tokens\n    triplets_total\n    indexed_for_seconds\n  }\n  config {\n    chunk_overlap_tokens\n    chunk_size_tokens\n    cost_limit\n    need_qa\n    qa_count_per_run\n    qa_model\n    force_confirm\n    instruction_for_qa\n  }\n}": types.IndexingDocumentTaskFieldsFragmentDoc,
    "query KDBIndexingDocumentTaskGet($session: Session!, $taskID: TaskID!) {\n  kdbIndexingDocumentTaskGet(session: $session, taskID: $taskID) {\n    ...IndexingDocumentTaskFields\n  }\n}": types.KdbIndexingDocumentTaskGetDocument,
    "query kdbIndexingDocumentTaskGetByCollection($session: Session!, $collections: [CollectionID!]!, $states: [IndexingDocumentTaskState!] = []) {\n  kdbIndexingDocumentTaskGetByCollection(\n    session: $session\n    collection_id: $collections\n    state: $states\n  ) {\n    ...IndexingDocumentTaskFields\n  }\n}": types.KdbIndexingDocumentTaskGetByCollectionDocument,
    "query kdbIndexingDocumentTaskGetByDocument($session: Session!, $document_id: [DocumentID!]!, $state: [IndexingDocumentTaskState!] = []) {\n  kdbIndexingDocumentTaskGetByDocument(\n    session: $session\n    document_id: $document_id\n    state: $state\n  ) {\n    ...IndexingDocumentTaskFields\n  }\n}": types.KdbIndexingDocumentTaskGetByDocumentDocument,
    "query KDBIndexingDocumentTaskGetByState($session: Session!, $state: [IndexingDocumentTaskState!]!, $limit: Int! = 100) {\n  kdbIndexingDocumentTaskGetByState(\n    session: $session\n    state: $state\n    limit: $limit\n  ) {\n    ...IndexingDocumentTaskFields\n  }\n}": types.KdbIndexingDocumentTaskGetByStateDocument,
    "fragment PageFields on Page {\n  page_id\n  content\n  description\n  document_id\n  task_id\n  indexing_state {\n    completion_cost\n    completion_tokens\n    content_tokens\n    embedding_cost\n    is_embedded\n    is_indexed_qa\n    is_indexed_triplet\n    is_parsed\n    is_summarized\n    prompt_cost\n    prompt_tokens\n  }\n  number\n}": types.PageFieldsFragmentDoc,
    "fragment QaFields on QA {\n  answer\n  answer_tokens\n  chunk_id\n  chunk_number\n  created_at\n  document_id\n  document_published_at\n  indexing_state {\n    completion_cost\n    completion_tokens\n    content_tokens\n    embedding_cost\n    is_embedded\n    is_indexed_qa\n    is_indexed_triplet\n    is_parsed\n    is_summarized\n    prompt_cost\n    prompt_tokens\n  }\n  model\n  page_number_from\n  page_number_to\n  qa_id\n  question\n  question_tokens\n  task_id\n}\n\nfragment QaWithDistanceFields on QAWithDistance {\n  qa {\n    ...QaFields\n  }\n  distance\n}\n\nfragment QAWithDocumentsFields on QAWithDocuments {\n  document {\n    ...DocumentFields\n  }\n  qas {\n    ...QaWithDistanceFields\n  }\n}": types.QaFieldsFragmentDoc,
    "query KDBQueryCollectionQA($session: Session!, $collection_id: [CollectionID!]!, $queryString: String!, $threshold: Float! = 0.5, $limit: Int! = 20, $tokensLimit: Int! = 4000) {\n  kdbQueryCollectionQA(\n    session: $session\n    collection_id: $collection_id\n    queryString: $queryString\n    threshold: $threshold\n    limit: $limit\n    tokensLimit: $tokensLimit\n  ) {\n    ...QaWithDistanceFields\n  }\n}": types.KdbQueryCollectionQaDocument,
    "query kdbQueryCollectionQAWithDocuments($session: Session!, $collection_id: [CollectionID!]!, $queryString: String!, $threshold: Float! = 0.5, $limit: Int! = 20, $tokensLimit: Int! = 4000) {\n  kdbQueryCollectionQAWithDocuments(\n    session: $session\n    collection_id: $collection_id\n    queryString: $queryString\n    threshold: $threshold\n    limit: $limit\n    tokensLimit: $tokensLimit\n  ) {\n    ...QAWithDocumentsFields\n  }\n}": types.KdbQueryCollectionQaWithDocumentsDocument,
    "query KDBQueryParticipantCollectionQA($session: Session!, $participantID: ParticipantID!, $queryString: String!, $threshold: Float! = 0.5, $limit: Int! = 20, $tokensLimit: Int! = 4000) {\n  kdbQueryParticipantCollectionQA(\n    session: $session\n    participantID: $participantID\n    queryString: $queryString\n    threshold: $threshold\n    limit: $limit\n    tokensLimit: $tokensLimit\n  ) {\n    ...QaWithDistanceFields\n  }\n}": types.KdbQueryParticipantCollectionQaDocument,
    "query kdbSearchQAWithDocuments($session: Session!, $collections: [CollectionID!]!, $queries: [String!]!, $queries_weights: [Float!], $options: SearchQAOptions, $filters: SearchQAFilters, $order_by: SearchQAOrderBy) {\n  kdbSearchQAWithDocuments(\n    session: $session\n    collections: $collections\n    queries: $queries\n    queries_weights: $queries_weights\n    options: $options\n    filters: $filters\n    order_by: $order_by\n  ) {\n    document {\n      ...DocumentFields\n    }\n    qas {\n      qa {\n        answer\n        answer_tokens\n        chunk_id\n        chunk_number\n        created_at\n        document_id\n        document_published_at\n        indexing_state {\n          completion_cost\n          completion_tokens\n          content_tokens\n          embedding_cost\n          is_embedded\n          is_indexed_qa\n          is_indexed_triplet\n          is_parsed\n          is_summarized\n          prompt_cost\n          prompt_tokens\n        }\n        model\n        page_number_from\n        page_number_to\n        qa_id\n        question\n        question_tokens\n        task_id\n      }\n      similarity\n    }\n  }\n}": types.KdbSearchQaWithDocumentsDocument,
    "mutation KDBCreateChunk($session: Session!, $chunks: [ChunkInput!]!) {\n  kdbCreateChunk(session: $session, chunks: $chunks) {\n    ...ChunkFields\n  }\n}": types.KdbCreateChunkDocument,
    "mutation KDBCreateCollection($session: Session!, $input: CreateAgentCollectionInput!) {\n  kdbCreateAgentCollection(session: $session, input: $input) {\n    collection_id\n  }\n}": types.KdbCreateCollectionDocument,
    "mutation KDBCreateDocument($session: Session!, $doc: DocumentMetaInput!) {\n  kdbCreateDocument(session: $session, doc: $doc) {\n    document_id\n    collection_id\n    url\n    created_at\n    published_at\n    name\n    description\n    tags\n    metadata {\n      key\n      value\n    }\n    indexing_state {\n      completion_cost\n      completion_tokens\n      content_tokens\n      embedding_cost\n      is_embedded\n      is_indexed_qa\n      is_indexed_triplet\n      is_parsed\n      is_summarized\n      prompt_cost\n      prompt_tokens\n    }\n  }\n}": types.KdbCreateDocumentDocument,
    "mutation KDBCreatePage($session: Session!, $pages: [PageInput!]!) {\n  kdbCreatePage(session: $session, pages: $pages) {\n    page_id\n    content\n    description\n    document_id\n    task_id\n    indexing_state {\n      completion_cost\n      completion_tokens\n      content_tokens\n      embedding_cost\n      is_embedded\n      is_indexed_qa\n      is_indexed_triplet\n      is_parsed\n      is_summarized\n      prompt_cost\n      prompt_tokens\n    }\n    number\n  }\n}": types.KdbCreatePageDocument,
    "mutation KDBCreateQA($session: Session!, $qa: CreateQAInput!) {\n  kdbCreateQA(session: $session, qa: $qa) {\n    ...QaFields\n  }\n}": types.KdbCreateQaDocument,
    "mutation KDBCreateTriplet($session: Session!, $triplets: CreateTripletInput!) {\n  kdbCreateTriplet(session: $session, triplet: $triplets) {\n    chunk_id\n    document_id\n    task_id\n    object\n    predicate\n    subject\n    triplet_id\n    indexing_state {\n      completion_cost\n      completion_tokens\n      content_tokens\n      embedding_cost\n      is_embedded\n      is_indexed_qa\n      is_indexed_triplet\n      is_parsed\n      is_summarized\n      prompt_cost\n      prompt_tokens\n    }\n  }\n}": types.KdbCreateTripletDocument,
    "mutation KDBIndexingDocumentTaskCreate($session: Session!, $input: KdbIndexingDocumentTaskCreateInput!) {\n  kdbIndexingDocumentTaskCreate(session: $session, input: $input) {\n    task_id\n    document_id\n    chat_id\n    message_id\n    author_id\n    task_state\n    created_at\n    update_at\n    confirmed\n    version\n    error\n    statistics {\n      chunks_indexed_qa\n      chunks_indexed_triplet\n      chunks_total\n      current_indexing_speed\n      expected_finish_seconds\n      expected_finished_at\n      indexed_percent\n      indexing_started_at\n      llm_approximate_cost\n      llm_stats {\n        completion_cost\n        embeddings_cost\n        embeddings_count\n        prompt_cost\n        total_cost\n      }\n      pages\n      qa_total\n      total_tokens\n      triplets_total\n      indexed_for_seconds\n    }\n    config {\n      chunk_overlap_tokens\n      chunk_size_tokens\n      cost_limit\n      need_qa\n      qa_count_per_run\n      qa_model\n      force_confirm\n      instruction_for_qa\n    }\n  }\n}": types.KdbIndexingDocumentTaskCreateDocument,
    "mutation KDBIndexingDocumentTaskError($session: Session!, $taskID: TaskID!, $version: Int!, $error: String!) {\n  kdbIndexingDocumentTaskError(\n    session: $session\n    taskID: $taskID\n    version: $version\n    error: $error\n  ) {\n    ...IndexingDocumentTaskFields\n  }\n}": types.KdbIndexingDocumentTaskErrorDocument,
    "mutation KDBIndexingDocumentTaskTransitionState($session: Session!, $taskID: TaskID!, $toState: IndexingDocumentTaskState!, $version: Int!) {\n  kdbIndexingDocumentTaskTransitionState(\n    session: $session\n    taskID: $taskID\n    toState: $toState\n    version: $version\n  ) {\n    ...IndexingDocumentTaskFields\n  }\n}": types.KdbIndexingDocumentTaskTransitionStateDocument,
    "query MarketplaceAgent($session: Session!, $agent_id: AgentID!) {\n  marketplaceAgent(session: $session, agent_id: $agent_id) {\n    agent_id\n    username\n    first_name\n    last_name\n    avatar\n    role\n    can_answer\n    owner_id\n    chain_graph_id\n    llm_config {\n      model\n      max_tokens\n      temperature\n    }\n    template_params\n    purpose\n    prompt\n    self_awareness\n    tools {\n      name\n    }\n    llm_model\n    chat_history_config {\n      messages_count\n      tokens_limit\n    }\n  }\n}": types.MarketplaceAgentDocument,
    "fragment agentFields on AgentMeta {\n  agent_id\n  username\n  owner_id\n  first_name\n  last_name\n  avatar\n  role\n  can_answer\n  chain_graph_id\n  skeleton\n  template_params\n  llm_config {\n    model\n    temperature\n    max_tokens\n  }\n  is_agent\n  deployment_status\n  prompt\n  chat_history_config {\n    messages_count\n    tokens_limit\n  }\n  llm_model\n  purpose\n  self_awareness\n  tools {\n    name\n  }\n}\n\nfragment agentCollectionFields on AgentCollection {\n  collection_id\n  title\n  description\n  owner_id\n  order\n  updated_at\n  agents {\n    ...agentFields\n  }\n}\n\nquery MarketplaceAgents($session: Session!) {\n  marketplaceAgents(session: $session) {\n    ...agentCollectionFields\n  }\n}": types.AgentFieldsFragmentDoc,
    "fragment MessageFields on Message {\n  attachments {\n    filename\n    id\n    mime_type\n    size\n    url\n  }\n  author\n  chat_id\n  deleted\n  error\n  finished\n  id\n  is_system\n  meta\n  need_answer\n  participant {\n    agent_id\n    avatar\n    first_name\n    is_agent\n    last_name\n    llm_model\n    meta\n    participant_id\n    purpose\n    role\n    self_awareness\n    tools {\n      name\n    }\n    username\n  }\n  reply_to\n  text\n  time\n  total_usage_cost\n  type\n  version\n  signals {\n    message_id\n    ... on AgentTriggeredSignal {\n      message_id\n      agent_id\n    }\n  }\n}": types.MessageFieldsFragmentDoc,
    "mutation AuthAgentLogin($agentID: AgentID!, $session: Session!) {\n  authAgentLogin(agentID: $agentID, session: $session) {\n    session\n    user_profile {\n      id\n      name\n      picture\n    }\n  }\n}": types.AuthAgentLoginDocument,
    "mutation AppendUsages($session: Session!, $usages: [UsageInput!]!) {\n  appendUsages(session: $session, usages: $usages)\n}": types.AppendUsagesDocument,
    "mutation AuthMetamaskLogin($input: MetamaskLoginInput!) {\n  authMetamaskLogin(input: $input) {\n    session\n    user_profile {\n      id\n      name\n      picture\n    }\n  }\n}": types.AuthMetamaskLoginDocument,
    "mutation UploadAttachment($session: Session!, $attachment: AttachmentBlob!) {\n  uploadAttachment(session: $session, attachment: $attachment) {\n    id\n    mime_type\n    url\n  }\n}": types.UploadAttachmentDocument,
    "mutation VoiceToText($session: Session!, $attachment_id: AttachmentID!) {\n  voiceToText(session: $session, attachment_id: $attachment_id) {\n    language\n    tokens\n    text\n    avg_logprob\n    no_speech_prob\n    temperature\n    compression_ratio\n  }\n}": types.VoiceToTextDocument,
    "subscription SubscribeChatRooms($session: Session!, $limit_chats: Int) {\n  subscribeChatRooms(session: $session, limit_chats: $limit_chats) {\n    sub_id\n    event\n    chat_rooms {\n      id\n      name\n      author\n      created_at\n      deleted_at\n      deleted\n      participants {\n        participant_id\n        agent_id\n        first_name\n        last_name\n        username\n        avatar\n        is_agent\n        role\n        purpose\n        self_awareness\n        tools {\n          name\n        }\n        llm_model\n        meta\n      }\n      meta\n    }\n    participants {\n      participant_id\n      agent_id\n      avatar\n      first_name\n      is_agent\n      last_name\n      purpose\n      role\n      self_awareness\n      username\n      tools {\n        name\n      }\n      llm_model\n      meta\n    }\n  }\n}": types.SubscribeChatRoomsDocument,
    "subscription SubscribeMessages($session: Session!, $chat_id: ChatID!, $limitMessages: Int! = 100) {\n  subscribeMessages(\n    session: $session\n    chat_id: $chat_id\n    limitMessages: $limitMessages\n  ) {\n    event\n    sub_id\n    message {\n      ...MessageFields\n    }\n    messages {\n      ...MessageFields\n    }\n  }\n}": types.SubscribeMessagesDocument,
    "query GetUserProfile($session: Session!) {\n  userProfile(session: $session) {\n    email\n    externalAccounts {\n      ID\n      providerID\n    }\n    id\n    name\n    picture\n    role\n    tariffCurrent\n    tariffExpires\n  }\n}": types.GetUserProfileDocument,
    "fragment variableFields on Variable {\n  id\n  namespace\n  key\n  value {\n    type\n    value\n  }\n  createdAt\n  updatedAt\n}\n\nquery GetVariable($session: Session!, $namespace: NamespaceInput!, $key: String!) {\n  getVariable(session: $session, namespace: $namespace, key: $key) {\n    variable {\n      ...variableFields\n    }\n  }\n}\n\nquery GetVariables($session: Session!, $namespace: NamespaceInput!) {\n  getVariables(session: $session, namespace: $namespace) {\n    variables {\n      ...variableFields\n    }\n  }\n}\n\nmutation SetVariable($session: Session!, $namespace: NamespaceInput!, $key: String!, $value: VariableValueInput!) {\n  setVariable(session: $session, namespace: $namespace, key: $key, value: $value) {\n    variable {\n      ...variableFields\n    }\n  }\n}\n\nmutation SetVariables($session: Session!, $namespace: NamespaceInput!, $variables: [KeyValueInput!]!) {\n  setVariables(session: $session, namespace: $namespace, variables: $variables) {\n    variables {\n      ...variableFields\n    }\n  }\n}\n\nmutation DeleteVariable($session: Session!, $namespace: NamespaceInput!, $key: String!) {\n  deleteVariable(session: $session, namespace: $namespace, key: $key)\n}\n\nmutation DeleteVariables($session: Session!, $namespace: NamespaceInput!) {\n  deleteVariables(session: $session, namespace: $namespace)\n}\n\nmutation AppendVariable($session: Session!, $namespace: NamespaceInput!, $key: String!, $value: VariableValueInput!) {\n  appendVariable(\n    session: $session\n    namespace: $namespace\n    key: $key\n    value: $value\n  ) {\n    variable {\n      ...variableFields\n    }\n  }\n}": types.VariableFieldsFragmentDoc,
    "query ReadSecret($session: Session!, $id: SecretID!, $publicKey: ECDHPublicKeyP256!) {\n  secret(session: $session, id: $id, publicKey: $publicKey) {\n    hkdfNonce\n    publicKey\n    secret {\n      encrypted\n      metadata {\n        type\n      }\n    }\n  }\n}": types.ReadSecretDocument,
};

/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 *
 *
 * @example
 * ```ts
 * const query = graphql(`query GetUser($id: ID!) { user(id: $id) { name } }`);
 * ```
 *
 * The query argument is unknown!
 * Please regenerate the types.
 */
export function graphql(source: string): unknown;

/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "query AdminAgentGetTwitterApiKeys($session: Session!, $agent_id: AgentID!) {\n  adminAgentGetTwitterApiKeys(session: $session, agent_id: $agent_id) {\n    access_token\n    access_token_secret\n    consumer_key\n    consumer_secret\n  }\n}"): (typeof documents)["query AdminAgentGetTwitterApiKeys($session: Session!, $agent_id: AgentID!) {\n  adminAgentGetTwitterApiKeys(session: $session, agent_id: $agent_id) {\n    access_token\n    access_token_secret\n    consumer_key\n    consumer_secret\n  }\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "query AdminGetParticipantTelegramBotAPIKey($session: Session!, $chat_id: ChatID!) {\n  adminGetParticipantTelegramBotApiKey(session: $session, chat_id: $chat_id)\n}"): (typeof documents)["query AdminGetParticipantTelegramBotAPIKey($session: Session!, $chat_id: ChatID!) {\n  adminGetParticipantTelegramBotApiKey(session: $session, chat_id: $chat_id)\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "query chainGraphGet($session: Session!, $chat_id: ChatID!, $participant_id: ParticipantID!) {\n  chainGraphGet(\n    session: $session\n    chat_id: $chat_id\n    participant_id: $participant_id\n  ) {\n    author\n    created_at\n    graph\n    graph_id\n  }\n}"): (typeof documents)["query chainGraphGet($session: Session!, $chat_id: ChatID!, $participant_id: ParticipantID!) {\n  chainGraphGet(\n    session: $session\n    chat_id: $chat_id\n    participant_id: $participant_id\n  ) {\n    author\n    created_at\n    graph\n    graph_id\n  }\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "query ChatRoomGetParticipant($session: Session!, $chat_id: ChatID!, $participant_id: ParticipantID!) {\n  chatRoomGetParticipant(\n    session: $session\n    chat_id: $chat_id\n    participant_id: $participant_id\n  ) {\n    agent_id\n    avatar\n    first_name\n    is_agent\n    last_name\n    participant_id\n    purpose\n    role\n    self_awareness\n    tools {\n      name\n    }\n    username\n    llm_model\n    meta\n  }\n}"): (typeof documents)["query ChatRoomGetParticipant($session: Session!, $chat_id: ChatID!, $participant_id: ParticipantID!) {\n  chatRoomGetParticipant(\n    session: $session\n    chat_id: $chat_id\n    participant_id: $participant_id\n  ) {\n    agent_id\n    avatar\n    first_name\n    is_agent\n    last_name\n    participant_id\n    purpose\n    role\n    self_awareness\n    tools {\n      name\n    }\n    username\n    llm_model\n    meta\n  }\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "query ChatRoomGetParticipants($session: Session!, $chat_id: ChatID!) {\n  chatRoomGetParticipants(session: $session, chat_id: $chat_id) {\n    agent_id\n    avatar\n    first_name\n    is_agent\n    last_name\n    participant_id\n    purpose\n    role\n    self_awareness\n    tools {\n      name\n    }\n    username\n    llm_model\n    meta\n  }\n}"): (typeof documents)["query ChatRoomGetParticipants($session: Session!, $chat_id: ChatID!) {\n  chatRoomGetParticipants(session: $session, chat_id: $chat_id) {\n    agent_id\n    avatar\n    first_name\n    is_agent\n    last_name\n    participant_id\n    purpose\n    role\n    self_awareness\n    tools {\n      name\n    }\n    username\n    llm_model\n    meta\n  }\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "query GetChatRoom($session: Session!, $chat_id: ChatID!) {\n  getChatRoom(session: $session, chat_id: $chat_id) {\n    id\n    name\n    author\n    created_at\n    deleted_at\n    deleted\n    updated_at\n    last_message_time\n    last_message {\n      ...MessageFields\n    }\n    participants {\n      participant_id\n      agent_id\n      first_name\n      last_name\n      username\n      avatar\n      is_agent\n      role\n      purpose\n      self_awareness\n      tools {\n        name\n      }\n      llm_model\n      meta\n    }\n    meta\n  }\n}"): (typeof documents)["query GetChatRoom($session: Session!, $chat_id: ChatID!) {\n  getChatRoom(session: $session, chat_id: $chat_id) {\n    id\n    name\n    author\n    created_at\n    deleted_at\n    deleted\n    updated_at\n    last_message_time\n    last_message {\n      ...MessageFields\n    }\n    participants {\n      participant_id\n      agent_id\n      first_name\n      last_name\n      username\n      avatar\n      is_agent\n      role\n      purpose\n      self_awareness\n      tools {\n        name\n      }\n      llm_model\n      meta\n    }\n    meta\n  }\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "query GetChatRooms($session: Session!) {\n  getChatRooms(session: $session) {\n    id\n    name\n    author\n    created_at\n    deleted_at\n    deleted\n    updated_at\n    last_message_time\n    last_message {\n      ...MessageFields\n    }\n    participants {\n      participant_id\n      agent_id\n      first_name\n      last_name\n      username\n      avatar\n      is_agent\n      role\n      purpose\n      self_awareness\n      tools {\n        name\n      }\n      llm_model\n      meta\n    }\n    meta\n  }\n}"): (typeof documents)["query GetChatRooms($session: Session!) {\n  getChatRooms(session: $session) {\n    id\n    name\n    author\n    created_at\n    deleted_at\n    deleted\n    updated_at\n    last_message_time\n    last_message {\n      ...MessageFields\n    }\n    participants {\n      participant_id\n      agent_id\n      first_name\n      last_name\n      username\n      avatar\n      is_agent\n      role\n      purpose\n      self_awareness\n      tools {\n        name\n      }\n      llm_model\n      meta\n    }\n    meta\n  }\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "query GetMessage($session: Session!, $chat_id: ChatID!, $id: MessageID!) {\n  message(session: $session, chat_id: $chat_id, id: $id) {\n    ...MessageFields\n  }\n}"): (typeof documents)["query GetMessage($session: Session!, $chat_id: ChatID!, $id: MessageID!) {\n  message(session: $session, chat_id: $chat_id, id: $id) {\n    ...MessageFields\n  }\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "query GetMessages($session: Session!, $chat_id: ChatID!, $from: MessageID!, $limit: Int, $order: String) {\n  messages(\n    session: $session\n    chat_id: $chat_id\n    from: $from\n    limit: $limit\n    order: $order\n  ) {\n    ...MessageFields\n  }\n}"): (typeof documents)["query GetMessages($session: Session!, $chat_id: ChatID!, $from: MessageID!, $limit: Int, $order: String) {\n  messages(\n    session: $session\n    chat_id: $chat_id\n    from: $from\n    limit: $limit\n    order: $order\n  ) {\n    ...MessageFields\n  }\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "query GetMessagesWithoutSystem($session: Session!, $chat_id: ChatID!, $from: MessageID!, $limit: Int, $order: String) {\n  messagesWithoutSystem(\n    session: $session\n    chat_id: $chat_id\n    from: $from\n    limit: $limit\n    order: $order\n  ) {\n    ...MessageFields\n  }\n}"): (typeof documents)["query GetMessagesWithoutSystem($session: Session!, $chat_id: ChatID!, $from: MessageID!, $limit: Int, $order: String) {\n  messagesWithoutSystem(\n    session: $session\n    chat_id: $chat_id\n    from: $from\n    limit: $limit\n    order: $order\n  ) {\n    ...MessageFields\n  }\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "mutation AddAgentToChat($session: Session!, $chat_id: ChatID!, $agent_id: AgentID!) {\n  addAgentToChat(session: $session, chat_id: $chat_id, agent_id: $agent_id)\n}"): (typeof documents)["mutation AddAgentToChat($session: Session!, $chat_id: ChatID!, $agent_id: AgentID!) {\n  addAgentToChat(session: $session, chat_id: $chat_id, agent_id: $agent_id)\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "mutation MessageAddDelta($session: Session!, $chat_id: ChatID!, $message_id: MessageID!, $delta: String!) {\n  addDelta(session: $session, chat_id: $chat_id, id: $message_id, delta: $delta) {\n    id\n    chat_id\n    text\n    version\n  }\n}"): (typeof documents)["mutation MessageAddDelta($session: Session!, $chat_id: ChatID!, $message_id: MessageID!, $delta: String!) {\n  addDelta(session: $session, chat_id: $chat_id, id: $message_id, delta: $delta) {\n    id\n    chat_id\n    text\n    version\n  }\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "mutation AddMessageAttachment($session: Session!, $chat_id: ChatID!, $id: MessageID!, $attachment_id: AttachmentID!) {\n  addMessageAttachment(\n    session: $session\n    chat_id: $chat_id\n    id: $id\n    attachment_id: $attachment_id\n  ) {\n    ...MessageFields\n  }\n}"): (typeof documents)["mutation AddMessageAttachment($session: Session!, $chat_id: ChatID!, $id: MessageID!, $attachment_id: AttachmentID!) {\n  addMessageAttachment(\n    session: $session\n    chat_id: $chat_id\n    id: $id\n    attachment_id: $attachment_id\n  ) {\n    ...MessageFields\n  }\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "mutation ChatRoomCreateParticipant($session: Session!, $chat_id: ChatID!, $input: ParticipantInput!) {\n  chatRoomCreateParticipant(session: $session, chat_id: $chat_id, input: $input) {\n    agent_id\n    avatar\n    first_name\n    is_agent\n    last_name\n    participant_id\n    purpose\n    role\n    self_awareness\n    tools {\n      name\n    }\n    username\n    llm_model\n    meta\n  }\n}"): (typeof documents)["mutation ChatRoomCreateParticipant($session: Session!, $chat_id: ChatID!, $input: ParticipantInput!) {\n  chatRoomCreateParticipant(session: $session, chat_id: $chat_id, input: $input) {\n    agent_id\n    avatar\n    first_name\n    is_agent\n    last_name\n    participant_id\n    purpose\n    role\n    self_awareness\n    tools {\n      name\n    }\n    username\n    llm_model\n    meta\n  }\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "mutation ChatRoomUpdateParticipant($session: Session!, $chat_id: ChatID!, $participant_id: ParticipantID!, $input: ParticipantInput!) {\n  chatRoomUpdateParticipant(\n    session: $session\n    chat_id: $chat_id\n    participant_id: $participant_id\n    input: $input\n  ) {\n    agent_id\n    avatar\n    first_name\n    is_agent\n    last_name\n    participant_id\n    purpose\n    role\n    self_awareness\n    tools {\n      name\n    }\n    username\n    llm_model\n    meta\n  }\n}"): (typeof documents)["mutation ChatRoomUpdateParticipant($session: Session!, $chat_id: ChatID!, $participant_id: ParticipantID!, $input: ParticipantInput!) {\n  chatRoomUpdateParticipant(\n    session: $session\n    chat_id: $chat_id\n    participant_id: $participant_id\n    input: $input\n  ) {\n    agent_id\n    avatar\n    first_name\n    is_agent\n    last_name\n    participant_id\n    purpose\n    role\n    self_awareness\n    tools {\n      name\n    }\n    username\n    llm_model\n    meta\n  }\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "mutation CreateChatRoom($session: Session!, $agents: [AgentID!] = []) {\n  createChatRoom(session: $session, agents: $agents) {\n    id\n    name\n    author\n    created_at\n    deleted_at\n    deleted\n    updated_at\n    last_message_time\n    last_message {\n      ...MessageFields\n    }\n    participants {\n      agent_id\n      avatar\n      first_name\n      is_agent\n      last_name\n      participant_id\n      purpose\n      role\n      self_awareness\n      tools {\n        name\n      }\n      username\n      llm_model\n      meta\n    }\n    meta\n  }\n}"): (typeof documents)["mutation CreateChatRoom($session: Session!, $agents: [AgentID!] = []) {\n  createChatRoom(session: $session, agents: $agents) {\n    id\n    name\n    author\n    created_at\n    deleted_at\n    deleted\n    updated_at\n    last_message_time\n    last_message {\n      ...MessageFields\n    }\n    participants {\n      agent_id\n      avatar\n      first_name\n      is_agent\n      last_name\n      participant_id\n      purpose\n      role\n      self_awareness\n      tools {\n        name\n      }\n      username\n      llm_model\n      meta\n    }\n    meta\n  }\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "mutation DeleteChatRoom($session: Session!, $chatID: ChatID!) {\n  deleteChatRoom(session: $session, id: $chatID)\n}"): (typeof documents)["mutation DeleteChatRoom($session: Session!, $chatID: ChatID!) {\n  deleteChatRoom(session: $session, id: $chatID)\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "mutation DeleteMessage($session: Session!, $chat_id: ChatID!, $message_id: MessageID!) {\n  deleteMessage(session: $session, chat_id: $chat_id, id: $message_id) {\n    ...MessageFields\n  }\n}"): (typeof documents)["mutation DeleteMessage($session: Session!, $chat_id: ChatID!, $message_id: MessageID!) {\n  deleteMessage(session: $session, chat_id: $chat_id, id: $message_id) {\n    ...MessageFields\n  }\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "mutation EditMessage($session: Session!, $chat_id: ChatID!, $id: MessageID!, $message: MessageEditInput!) {\n  editMessage(session: $session, chat_id: $chat_id, id: $id, message: $message) {\n    ...MessageFields\n  }\n}"): (typeof documents)["mutation EditMessage($session: Session!, $chat_id: ChatID!, $id: MessageID!, $message: MessageEditInput!) {\n  editMessage(session: $session, chat_id: $chat_id, id: $id, message: $message) {\n    ...MessageFields\n  }\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "mutation FinishMessage($session: Session!, $chat_id: ChatID!, $id: MessageID!) {\n  finishMessage(session: $session, chat_id: $chat_id, id: $id) {\n    ...MessageFields\n  }\n}"): (typeof documents)["mutation FinishMessage($session: Session!, $chat_id: ChatID!, $id: MessageID!) {\n  finishMessage(session: $session, chat_id: $chat_id, id: $id) {\n    ...MessageFields\n  }\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "mutation RegenerateLastResponse($session: Session!, $chat_id: ChatID!) {\n  regenerateLastResponse(session: $session, chat_id: $chat_id)\n}"): (typeof documents)["mutation RegenerateLastResponse($session: Session!, $chat_id: ChatID!) {\n  regenerateLastResponse(session: $session, chat_id: $chat_id)\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "mutation RenameChatRoom($session: Session!, $id: ChatID!, $new_name: String!) {\n  renameChatRoom(session: $session, id: $id, new_name: $new_name) {\n    id\n    name\n    author\n    created_at\n    deleted_at\n    deleted\n    updated_at\n    last_message_time\n    last_message {\n      ...MessageFields\n    }\n    participants {\n      agent_id\n      avatar\n      first_name\n      is_agent\n      last_name\n      participant_id\n      purpose\n      role\n      self_awareness\n      tools {\n        name\n      }\n      username\n      llm_model\n      meta\n    }\n    meta\n  }\n}"): (typeof documents)["mutation RenameChatRoom($session: Session!, $id: ChatID!, $new_name: String!) {\n  renameChatRoom(session: $session, id: $id, new_name: $new_name) {\n    id\n    name\n    author\n    created_at\n    deleted_at\n    deleted\n    updated_at\n    last_message_time\n    last_message {\n      ...MessageFields\n    }\n    participants {\n      agent_id\n      avatar\n      first_name\n      is_agent\n      last_name\n      participant_id\n      purpose\n      role\n      self_awareness\n      tools {\n        name\n      }\n      username\n      llm_model\n      meta\n    }\n    meta\n  }\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "mutation SendMessage($session: Session!, $chat_id: ChatID!, $message: MessageInput!) {\n  sendMessage(session: $session, chat_id: $chat_id, message: $message) {\n    ...MessageFields\n  }\n}"): (typeof documents)["mutation SendMessage($session: Session!, $chat_id: ChatID!, $message: MessageInput!) {\n  sendMessage(session: $session, chat_id: $chat_id, message: $message) {\n    ...MessageFields\n  }\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "mutation SetMessageMeta($session: Session!, $chat_id: ChatID!, $id: MessageID!, $message_meta: MessageMetaInput!) {\n  setMessageMeta(\n    session: $session\n    chat_id: $chat_id\n    id: $id\n    message_meta: $message_meta\n  ) {\n    ...MessageFields\n  }\n}"): (typeof documents)["mutation SetMessageMeta($session: Session!, $chat_id: ChatID!, $id: MessageID!, $message_meta: MessageMetaInput!) {\n  setMessageMeta(\n    session: $session\n    chat_id: $chat_id\n    id: $id\n    message_meta: $message_meta\n  ) {\n    ...MessageFields\n  }\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "mutation StopCompletion($session: Session!, $chat_id: ChatID!) {\n  stopCompletion(session: $session, chat_id: $chat_id)\n}"): (typeof documents)["mutation StopCompletion($session: Session!, $chat_id: ChatID!) {\n  stopCompletion(session: $session, chat_id: $chat_id)\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "mutation UnsubscribeMessages($session: Session!, $chat_id: ChatID!, $sub_id: SubscriptionID!) {\n  unsubscribeMessages(session: $session, chat_id: $chat_id, sub_id: $sub_id)\n}"): (typeof documents)["mutation UnsubscribeMessages($session: Session!, $chat_id: ChatID!, $sub_id: SubscriptionID!) {\n  unsubscribeMessages(session: $session, chat_id: $chat_id, sub_id: $sub_id)\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "query AuthMetamaskMessage($address: MetamaskAddress!) {\n  authMetamaskMessage(address: $address)\n}"): (typeof documents)["query AuthMetamaskMessage($address: MetamaskAddress!) {\n  authMetamaskMessage(address: $address)\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "query GetTweetsFromDB($session: Session!, $tweets_ids: [TweetID!]!) {\n  getTweetsFromDB(session: $session, tweets_ids: $tweets_ids) {\n    ...TweetFields\n  }\n}\n\nfragment TwitterUserFields on TwitterUser {\n  created_at\n  description\n  id\n  name\n  profile_image_url\n  public_metrics {\n    followers_count\n    following_count\n    listed_count\n    tweet_count\n  }\n  url\n  username\n  verified\n}\n\nfragment TweetFields on Tweet {\n  tweet_id\n  text\n  author {\n    ...TwitterUserFields\n  }\n  conversation_id\n  in_reply_to_user_id\n  reply_to_tweet_id\n  created_at\n  mentioned_users {\n    ...TwitterUserFields\n  }\n  public_metrics {\n    like_count\n    quote_count\n    reply_count\n    retweet_count\n  }\n  quoted_tweet {\n    author {\n      ...TwitterUserFields\n    }\n    conversation_id\n    in_reply_to_user_id\n    reply_to_tweet_id\n    created_at\n    mentioned_users {\n      ...TwitterUserFields\n    }\n    public_metrics {\n      like_count\n      quote_count\n      reply_count\n      retweet_count\n    }\n    quoted_tweet {\n      tweet_id\n    }\n    reply_tweet {\n      tweet_id\n    }\n    text\n    tweet_id\n  }\n  reply_tweet {\n    author {\n      ...TwitterUserFields\n    }\n    conversation_id\n    in_reply_to_user_id\n    reply_to_tweet_id\n    created_at\n    mentioned_users {\n      ...TwitterUserFields\n    }\n    public_metrics {\n      like_count\n      quote_count\n      reply_count\n      retweet_count\n    }\n    quoted_tweet {\n      tweet_id\n    }\n    reply_tweet {\n      tweet_id\n    }\n    text\n    tweet_id\n  }\n}"): (typeof documents)["query GetTweetsFromDB($session: Session!, $tweets_ids: [TweetID!]!) {\n  getTweetsFromDB(session: $session, tweets_ids: $tweets_ids) {\n    ...TweetFields\n  }\n}\n\nfragment TwitterUserFields on TwitterUser {\n  created_at\n  description\n  id\n  name\n  profile_image_url\n  public_metrics {\n    followers_count\n    following_count\n    listed_count\n    tweet_count\n  }\n  url\n  username\n  verified\n}\n\nfragment TweetFields on Tweet {\n  tweet_id\n  text\n  author {\n    ...TwitterUserFields\n  }\n  conversation_id\n  in_reply_to_user_id\n  reply_to_tweet_id\n  created_at\n  mentioned_users {\n    ...TwitterUserFields\n  }\n  public_metrics {\n    like_count\n    quote_count\n    reply_count\n    retweet_count\n  }\n  quoted_tweet {\n    author {\n      ...TwitterUserFields\n    }\n    conversation_id\n    in_reply_to_user_id\n    reply_to_tweet_id\n    created_at\n    mentioned_users {\n      ...TwitterUserFields\n    }\n    public_metrics {\n      like_count\n      quote_count\n      reply_count\n      retweet_count\n    }\n    quoted_tweet {\n      tweet_id\n    }\n    reply_tweet {\n      tweet_id\n    }\n    text\n    tweet_id\n  }\n  reply_tweet {\n    author {\n      ...TwitterUserFields\n    }\n    conversation_id\n    in_reply_to_user_id\n    reply_to_tweet_id\n    created_at\n    mentioned_users {\n      ...TwitterUserFields\n    }\n    public_metrics {\n      like_count\n      quote_count\n      reply_count\n      retweet_count\n    }\n    quoted_tweet {\n      tweet_id\n    }\n    reply_tweet {\n      tweet_id\n    }\n    text\n    tweet_id\n  }\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "fragment ChunkFields on Chunk {\n  chunk_id\n  chunk_number\n  content\n  document_id\n  task_id\n  indexing_state {\n    completion_cost\n    completion_tokens\n    content_tokens\n    embedding_cost\n    is_embedded\n    is_indexed_qa\n    is_indexed_triplet\n    is_parsed\n    is_summarized\n    prompt_cost\n    prompt_tokens\n  }\n  page_number_from\n  page_number_to\n}"): (typeof documents)["fragment ChunkFields on Chunk {\n  chunk_id\n  chunk_number\n  content\n  document_id\n  task_id\n  indexing_state {\n    completion_cost\n    completion_tokens\n    content_tokens\n    embedding_cost\n    is_embedded\n    is_indexed_qa\n    is_indexed_triplet\n    is_parsed\n    is_summarized\n    prompt_cost\n    prompt_tokens\n  }\n  page_number_from\n  page_number_to\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "fragment CollectionFields on Collection {\n  collection_id\n  agent_id\n  creator_address\n  name\n  description\n  created_at\n  indexing_state {\n    completion_cost\n    completion_tokens\n    content_tokens\n    embedding_cost\n    is_embedded\n    is_indexed_qa\n    is_indexed_triplet\n    is_parsed\n    is_summarized\n    prompt_cost\n    prompt_tokens\n  }\n  tags\n}"): (typeof documents)["fragment CollectionFields on Collection {\n  collection_id\n  agent_id\n  creator_address\n  name\n  description\n  created_at\n  indexing_state {\n    completion_cost\n    completion_tokens\n    content_tokens\n    embedding_cost\n    is_embedded\n    is_indexed_qa\n    is_indexed_triplet\n    is_parsed\n    is_summarized\n    prompt_cost\n    prompt_tokens\n  }\n  tags\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "fragment DocumentFields on DocumentMeta {\n  document_id\n  collection_id\n  url\n  created_at\n  published_at\n  name\n  description\n  tags\n  metadata {\n    key\n    value\n  }\n  indexing_state {\n    completion_cost\n    completion_tokens\n    content_tokens\n    embedding_cost\n    is_embedded\n    is_indexed_qa\n    is_indexed_triplet\n    is_parsed\n    is_summarized\n    prompt_cost\n    prompt_tokens\n  }\n}"): (typeof documents)["fragment DocumentFields on DocumentMeta {\n  document_id\n  collection_id\n  url\n  created_at\n  published_at\n  name\n  description\n  tags\n  metadata {\n    key\n    value\n  }\n  indexing_state {\n    completion_cost\n    completion_tokens\n    content_tokens\n    embedding_cost\n    is_embedded\n    is_indexed_qa\n    is_indexed_triplet\n    is_parsed\n    is_summarized\n    prompt_cost\n    prompt_tokens\n  }\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "query KDBGetParticipantCollections($session: Session!, $agent_id: AgentID!) {\n  kdbGetAgentCollections(session: $session, agent_id: $agent_id) {\n    ...CollectionFields\n  }\n}"): (typeof documents)["query KDBGetParticipantCollections($session: Session!, $agent_id: AgentID!) {\n  kdbGetAgentCollections(session: $session, agent_id: $agent_id) {\n    ...CollectionFields\n  }\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "query KDBGetChunk($session: Session!, $chunk_id: ChunkID!) {\n  kdbGetChunk(session: $session, chunk_id: $chunk_id) {\n    ...ChunkFields\n  }\n}"): (typeof documents)["query KDBGetChunk($session: Session!, $chunk_id: ChunkID!) {\n  kdbGetChunk(session: $session, chunk_id: $chunk_id) {\n    ...ChunkFields\n  }\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "query KDBGetChunksByDocument($session: Session!, $document_id: DocumentID!) {\n  kdbGetChunksByDocument(session: $session, document_id: $document_id) {\n    ...ChunkFields\n  }\n}"): (typeof documents)["query KDBGetChunksByDocument($session: Session!, $document_id: DocumentID!) {\n  kdbGetChunksByDocument(session: $session, document_id: $document_id) {\n    ...ChunkFields\n  }\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "query KDBGetChunksByTask($session: Session!, $task_id: TaskID!) {\n  kdbGetChunksByTask(session: $session, task_id: $task_id) {\n    ...ChunkFields\n  }\n}"): (typeof documents)["query KDBGetChunksByTask($session: Session!, $task_id: TaskID!) {\n  kdbGetChunksByTask(session: $session, task_id: $task_id) {\n    ...ChunkFields\n  }\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "query KDBGetCollection($session: Session!, $collection_id: CollectionID!) {\n  kdbGetCollection(session: $session, collection_id: $collection_id) {\n    ...CollectionFields\n  }\n}"): (typeof documents)["query KDBGetCollection($session: Session!, $collection_id: CollectionID!) {\n  kdbGetCollection(session: $session, collection_id: $collection_id) {\n    ...CollectionFields\n  }\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "query KDBGetDocuments($session: Session!, $document_ids: [DocumentID!]!) {\n  kdbGetDocuments(session: $session, document_ids: $document_ids) {\n    ...DocumentFields\n  }\n}"): (typeof documents)["query KDBGetDocuments($session: Session!, $document_ids: [DocumentID!]!) {\n  kdbGetDocuments(session: $session, document_ids: $document_ids) {\n    ...DocumentFields\n  }\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "query KDBGetDocumentsByCollection($session: Session!, $collection_id: CollectionID!, $filters: GetDocumentsByCollectionFilters = {published_range: {}}, $order_by: GetDocumentsByCollectionOrderByInput!, $limit: Int = 1000) {\n  kdbGetDocumentsByCollection(\n    session: $session\n    collection_id: $collection_id\n    filters: $filters\n    order_by: $order_by\n    limit: $limit\n  ) {\n    document {\n      ...DocumentFields\n    }\n    pagesCount\n  }\n}"): (typeof documents)["query KDBGetDocumentsByCollection($session: Session!, $collection_id: CollectionID!, $filters: GetDocumentsByCollectionFilters = {published_range: {}}, $order_by: GetDocumentsByCollectionOrderByInput!, $limit: Int = 1000) {\n  kdbGetDocumentsByCollection(\n    session: $session\n    collection_id: $collection_id\n    filters: $filters\n    order_by: $order_by\n    limit: $limit\n  ) {\n    document {\n      ...DocumentFields\n    }\n    pagesCount\n  }\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "query KDBGetPagesByDocument($session: Session!, $document_id: DocumentID!, $filters: GetPagesByDocumentFilters = {}) {\n  kdbGetPagesByDocument(\n    session: $session\n    document_id: $document_id\n    filters: $filters\n  ) {\n    page_id\n    content\n    description\n    document_id\n    task_id\n    number\n  }\n}"): (typeof documents)["query KDBGetPagesByDocument($session: Session!, $document_id: DocumentID!, $filters: GetPagesByDocumentFilters = {}) {\n  kdbGetPagesByDocument(\n    session: $session\n    document_id: $document_id\n    filters: $filters\n  ) {\n    page_id\n    content\n    description\n    document_id\n    task_id\n    number\n  }\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "query KDBGetPagesByTask($session: Session!, $task_id: TaskID!) {\n  kdbGetPagesByTask(session: $session, task_id: $task_id) {\n    ...PageFields\n  }\n}"): (typeof documents)["query KDBGetPagesByTask($session: Session!, $task_id: TaskID!) {\n  kdbGetPagesByTask(session: $session, task_id: $task_id) {\n    ...PageFields\n  }\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "fragment IndexingDocumentTaskFields on IndexingDocumentTask {\n  task_id\n  document_id\n  chat_id\n  message_id\n  author_id\n  task_state\n  created_at\n  update_at\n  confirmed\n  version\n  error\n  statistics {\n    chunks_indexed_qa\n    chunks_indexed_triplet\n    chunks_total\n    current_indexing_speed\n    expected_finish_seconds\n    expected_finished_at\n    indexed_percent\n    indexing_started_at\n    llm_approximate_cost\n    llm_stats {\n      completion_cost\n      embeddings_cost\n      embeddings_count\n      prompt_cost\n      total_cost\n    }\n    pages\n    qa_total\n    total_tokens\n    triplets_total\n    indexed_for_seconds\n  }\n  config {\n    chunk_overlap_tokens\n    chunk_size_tokens\n    cost_limit\n    need_qa\n    qa_count_per_run\n    qa_model\n    force_confirm\n    instruction_for_qa\n  }\n}"): (typeof documents)["fragment IndexingDocumentTaskFields on IndexingDocumentTask {\n  task_id\n  document_id\n  chat_id\n  message_id\n  author_id\n  task_state\n  created_at\n  update_at\n  confirmed\n  version\n  error\n  statistics {\n    chunks_indexed_qa\n    chunks_indexed_triplet\n    chunks_total\n    current_indexing_speed\n    expected_finish_seconds\n    expected_finished_at\n    indexed_percent\n    indexing_started_at\n    llm_approximate_cost\n    llm_stats {\n      completion_cost\n      embeddings_cost\n      embeddings_count\n      prompt_cost\n      total_cost\n    }\n    pages\n    qa_total\n    total_tokens\n    triplets_total\n    indexed_for_seconds\n  }\n  config {\n    chunk_overlap_tokens\n    chunk_size_tokens\n    cost_limit\n    need_qa\n    qa_count_per_run\n    qa_model\n    force_confirm\n    instruction_for_qa\n  }\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "query KDBIndexingDocumentTaskGet($session: Session!, $taskID: TaskID!) {\n  kdbIndexingDocumentTaskGet(session: $session, taskID: $taskID) {\n    ...IndexingDocumentTaskFields\n  }\n}"): (typeof documents)["query KDBIndexingDocumentTaskGet($session: Session!, $taskID: TaskID!) {\n  kdbIndexingDocumentTaskGet(session: $session, taskID: $taskID) {\n    ...IndexingDocumentTaskFields\n  }\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "query kdbIndexingDocumentTaskGetByCollection($session: Session!, $collections: [CollectionID!]!, $states: [IndexingDocumentTaskState!] = []) {\n  kdbIndexingDocumentTaskGetByCollection(\n    session: $session\n    collection_id: $collections\n    state: $states\n  ) {\n    ...IndexingDocumentTaskFields\n  }\n}"): (typeof documents)["query kdbIndexingDocumentTaskGetByCollection($session: Session!, $collections: [CollectionID!]!, $states: [IndexingDocumentTaskState!] = []) {\n  kdbIndexingDocumentTaskGetByCollection(\n    session: $session\n    collection_id: $collections\n    state: $states\n  ) {\n    ...IndexingDocumentTaskFields\n  }\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "query kdbIndexingDocumentTaskGetByDocument($session: Session!, $document_id: [DocumentID!]!, $state: [IndexingDocumentTaskState!] = []) {\n  kdbIndexingDocumentTaskGetByDocument(\n    session: $session\n    document_id: $document_id\n    state: $state\n  ) {\n    ...IndexingDocumentTaskFields\n  }\n}"): (typeof documents)["query kdbIndexingDocumentTaskGetByDocument($session: Session!, $document_id: [DocumentID!]!, $state: [IndexingDocumentTaskState!] = []) {\n  kdbIndexingDocumentTaskGetByDocument(\n    session: $session\n    document_id: $document_id\n    state: $state\n  ) {\n    ...IndexingDocumentTaskFields\n  }\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "query KDBIndexingDocumentTaskGetByState($session: Session!, $state: [IndexingDocumentTaskState!]!, $limit: Int! = 100) {\n  kdbIndexingDocumentTaskGetByState(\n    session: $session\n    state: $state\n    limit: $limit\n  ) {\n    ...IndexingDocumentTaskFields\n  }\n}"): (typeof documents)["query KDBIndexingDocumentTaskGetByState($session: Session!, $state: [IndexingDocumentTaskState!]!, $limit: Int! = 100) {\n  kdbIndexingDocumentTaskGetByState(\n    session: $session\n    state: $state\n    limit: $limit\n  ) {\n    ...IndexingDocumentTaskFields\n  }\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "fragment PageFields on Page {\n  page_id\n  content\n  description\n  document_id\n  task_id\n  indexing_state {\n    completion_cost\n    completion_tokens\n    content_tokens\n    embedding_cost\n    is_embedded\n    is_indexed_qa\n    is_indexed_triplet\n    is_parsed\n    is_summarized\n    prompt_cost\n    prompt_tokens\n  }\n  number\n}"): (typeof documents)["fragment PageFields on Page {\n  page_id\n  content\n  description\n  document_id\n  task_id\n  indexing_state {\n    completion_cost\n    completion_tokens\n    content_tokens\n    embedding_cost\n    is_embedded\n    is_indexed_qa\n    is_indexed_triplet\n    is_parsed\n    is_summarized\n    prompt_cost\n    prompt_tokens\n  }\n  number\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "fragment QaFields on QA {\n  answer\n  answer_tokens\n  chunk_id\n  chunk_number\n  created_at\n  document_id\n  document_published_at\n  indexing_state {\n    completion_cost\n    completion_tokens\n    content_tokens\n    embedding_cost\n    is_embedded\n    is_indexed_qa\n    is_indexed_triplet\n    is_parsed\n    is_summarized\n    prompt_cost\n    prompt_tokens\n  }\n  model\n  page_number_from\n  page_number_to\n  qa_id\n  question\n  question_tokens\n  task_id\n}\n\nfragment QaWithDistanceFields on QAWithDistance {\n  qa {\n    ...QaFields\n  }\n  distance\n}\n\nfragment QAWithDocumentsFields on QAWithDocuments {\n  document {\n    ...DocumentFields\n  }\n  qas {\n    ...QaWithDistanceFields\n  }\n}"): (typeof documents)["fragment QaFields on QA {\n  answer\n  answer_tokens\n  chunk_id\n  chunk_number\n  created_at\n  document_id\n  document_published_at\n  indexing_state {\n    completion_cost\n    completion_tokens\n    content_tokens\n    embedding_cost\n    is_embedded\n    is_indexed_qa\n    is_indexed_triplet\n    is_parsed\n    is_summarized\n    prompt_cost\n    prompt_tokens\n  }\n  model\n  page_number_from\n  page_number_to\n  qa_id\n  question\n  question_tokens\n  task_id\n}\n\nfragment QaWithDistanceFields on QAWithDistance {\n  qa {\n    ...QaFields\n  }\n  distance\n}\n\nfragment QAWithDocumentsFields on QAWithDocuments {\n  document {\n    ...DocumentFields\n  }\n  qas {\n    ...QaWithDistanceFields\n  }\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "query KDBQueryCollectionQA($session: Session!, $collection_id: [CollectionID!]!, $queryString: String!, $threshold: Float! = 0.5, $limit: Int! = 20, $tokensLimit: Int! = 4000) {\n  kdbQueryCollectionQA(\n    session: $session\n    collection_id: $collection_id\n    queryString: $queryString\n    threshold: $threshold\n    limit: $limit\n    tokensLimit: $tokensLimit\n  ) {\n    ...QaWithDistanceFields\n  }\n}"): (typeof documents)["query KDBQueryCollectionQA($session: Session!, $collection_id: [CollectionID!]!, $queryString: String!, $threshold: Float! = 0.5, $limit: Int! = 20, $tokensLimit: Int! = 4000) {\n  kdbQueryCollectionQA(\n    session: $session\n    collection_id: $collection_id\n    queryString: $queryString\n    threshold: $threshold\n    limit: $limit\n    tokensLimit: $tokensLimit\n  ) {\n    ...QaWithDistanceFields\n  }\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "query kdbQueryCollectionQAWithDocuments($session: Session!, $collection_id: [CollectionID!]!, $queryString: String!, $threshold: Float! = 0.5, $limit: Int! = 20, $tokensLimit: Int! = 4000) {\n  kdbQueryCollectionQAWithDocuments(\n    session: $session\n    collection_id: $collection_id\n    queryString: $queryString\n    threshold: $threshold\n    limit: $limit\n    tokensLimit: $tokensLimit\n  ) {\n    ...QAWithDocumentsFields\n  }\n}"): (typeof documents)["query kdbQueryCollectionQAWithDocuments($session: Session!, $collection_id: [CollectionID!]!, $queryString: String!, $threshold: Float! = 0.5, $limit: Int! = 20, $tokensLimit: Int! = 4000) {\n  kdbQueryCollectionQAWithDocuments(\n    session: $session\n    collection_id: $collection_id\n    queryString: $queryString\n    threshold: $threshold\n    limit: $limit\n    tokensLimit: $tokensLimit\n  ) {\n    ...QAWithDocumentsFields\n  }\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "query KDBQueryParticipantCollectionQA($session: Session!, $participantID: ParticipantID!, $queryString: String!, $threshold: Float! = 0.5, $limit: Int! = 20, $tokensLimit: Int! = 4000) {\n  kdbQueryParticipantCollectionQA(\n    session: $session\n    participantID: $participantID\n    queryString: $queryString\n    threshold: $threshold\n    limit: $limit\n    tokensLimit: $tokensLimit\n  ) {\n    ...QaWithDistanceFields\n  }\n}"): (typeof documents)["query KDBQueryParticipantCollectionQA($session: Session!, $participantID: ParticipantID!, $queryString: String!, $threshold: Float! = 0.5, $limit: Int! = 20, $tokensLimit: Int! = 4000) {\n  kdbQueryParticipantCollectionQA(\n    session: $session\n    participantID: $participantID\n    queryString: $queryString\n    threshold: $threshold\n    limit: $limit\n    tokensLimit: $tokensLimit\n  ) {\n    ...QaWithDistanceFields\n  }\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "query kdbSearchQAWithDocuments($session: Session!, $collections: [CollectionID!]!, $queries: [String!]!, $queries_weights: [Float!], $options: SearchQAOptions, $filters: SearchQAFilters, $order_by: SearchQAOrderBy) {\n  kdbSearchQAWithDocuments(\n    session: $session\n    collections: $collections\n    queries: $queries\n    queries_weights: $queries_weights\n    options: $options\n    filters: $filters\n    order_by: $order_by\n  ) {\n    document {\n      ...DocumentFields\n    }\n    qas {\n      qa {\n        answer\n        answer_tokens\n        chunk_id\n        chunk_number\n        created_at\n        document_id\n        document_published_at\n        indexing_state {\n          completion_cost\n          completion_tokens\n          content_tokens\n          embedding_cost\n          is_embedded\n          is_indexed_qa\n          is_indexed_triplet\n          is_parsed\n          is_summarized\n          prompt_cost\n          prompt_tokens\n        }\n        model\n        page_number_from\n        page_number_to\n        qa_id\n        question\n        question_tokens\n        task_id\n      }\n      similarity\n    }\n  }\n}"): (typeof documents)["query kdbSearchQAWithDocuments($session: Session!, $collections: [CollectionID!]!, $queries: [String!]!, $queries_weights: [Float!], $options: SearchQAOptions, $filters: SearchQAFilters, $order_by: SearchQAOrderBy) {\n  kdbSearchQAWithDocuments(\n    session: $session\n    collections: $collections\n    queries: $queries\n    queries_weights: $queries_weights\n    options: $options\n    filters: $filters\n    order_by: $order_by\n  ) {\n    document {\n      ...DocumentFields\n    }\n    qas {\n      qa {\n        answer\n        answer_tokens\n        chunk_id\n        chunk_number\n        created_at\n        document_id\n        document_published_at\n        indexing_state {\n          completion_cost\n          completion_tokens\n          content_tokens\n          embedding_cost\n          is_embedded\n          is_indexed_qa\n          is_indexed_triplet\n          is_parsed\n          is_summarized\n          prompt_cost\n          prompt_tokens\n        }\n        model\n        page_number_from\n        page_number_to\n        qa_id\n        question\n        question_tokens\n        task_id\n      }\n      similarity\n    }\n  }\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "mutation KDBCreateChunk($session: Session!, $chunks: [ChunkInput!]!) {\n  kdbCreateChunk(session: $session, chunks: $chunks) {\n    ...ChunkFields\n  }\n}"): (typeof documents)["mutation KDBCreateChunk($session: Session!, $chunks: [ChunkInput!]!) {\n  kdbCreateChunk(session: $session, chunks: $chunks) {\n    ...ChunkFields\n  }\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "mutation KDBCreateCollection($session: Session!, $input: CreateAgentCollectionInput!) {\n  kdbCreateAgentCollection(session: $session, input: $input) {\n    collection_id\n  }\n}"): (typeof documents)["mutation KDBCreateCollection($session: Session!, $input: CreateAgentCollectionInput!) {\n  kdbCreateAgentCollection(session: $session, input: $input) {\n    collection_id\n  }\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "mutation KDBCreateDocument($session: Session!, $doc: DocumentMetaInput!) {\n  kdbCreateDocument(session: $session, doc: $doc) {\n    document_id\n    collection_id\n    url\n    created_at\n    published_at\n    name\n    description\n    tags\n    metadata {\n      key\n      value\n    }\n    indexing_state {\n      completion_cost\n      completion_tokens\n      content_tokens\n      embedding_cost\n      is_embedded\n      is_indexed_qa\n      is_indexed_triplet\n      is_parsed\n      is_summarized\n      prompt_cost\n      prompt_tokens\n    }\n  }\n}"): (typeof documents)["mutation KDBCreateDocument($session: Session!, $doc: DocumentMetaInput!) {\n  kdbCreateDocument(session: $session, doc: $doc) {\n    document_id\n    collection_id\n    url\n    created_at\n    published_at\n    name\n    description\n    tags\n    metadata {\n      key\n      value\n    }\n    indexing_state {\n      completion_cost\n      completion_tokens\n      content_tokens\n      embedding_cost\n      is_embedded\n      is_indexed_qa\n      is_indexed_triplet\n      is_parsed\n      is_summarized\n      prompt_cost\n      prompt_tokens\n    }\n  }\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "mutation KDBCreatePage($session: Session!, $pages: [PageInput!]!) {\n  kdbCreatePage(session: $session, pages: $pages) {\n    page_id\n    content\n    description\n    document_id\n    task_id\n    indexing_state {\n      completion_cost\n      completion_tokens\n      content_tokens\n      embedding_cost\n      is_embedded\n      is_indexed_qa\n      is_indexed_triplet\n      is_parsed\n      is_summarized\n      prompt_cost\n      prompt_tokens\n    }\n    number\n  }\n}"): (typeof documents)["mutation KDBCreatePage($session: Session!, $pages: [PageInput!]!) {\n  kdbCreatePage(session: $session, pages: $pages) {\n    page_id\n    content\n    description\n    document_id\n    task_id\n    indexing_state {\n      completion_cost\n      completion_tokens\n      content_tokens\n      embedding_cost\n      is_embedded\n      is_indexed_qa\n      is_indexed_triplet\n      is_parsed\n      is_summarized\n      prompt_cost\n      prompt_tokens\n    }\n    number\n  }\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "mutation KDBCreateQA($session: Session!, $qa: CreateQAInput!) {\n  kdbCreateQA(session: $session, qa: $qa) {\n    ...QaFields\n  }\n}"): (typeof documents)["mutation KDBCreateQA($session: Session!, $qa: CreateQAInput!) {\n  kdbCreateQA(session: $session, qa: $qa) {\n    ...QaFields\n  }\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "mutation KDBCreateTriplet($session: Session!, $triplets: CreateTripletInput!) {\n  kdbCreateTriplet(session: $session, triplet: $triplets) {\n    chunk_id\n    document_id\n    task_id\n    object\n    predicate\n    subject\n    triplet_id\n    indexing_state {\n      completion_cost\n      completion_tokens\n      content_tokens\n      embedding_cost\n      is_embedded\n      is_indexed_qa\n      is_indexed_triplet\n      is_parsed\n      is_summarized\n      prompt_cost\n      prompt_tokens\n    }\n  }\n}"): (typeof documents)["mutation KDBCreateTriplet($session: Session!, $triplets: CreateTripletInput!) {\n  kdbCreateTriplet(session: $session, triplet: $triplets) {\n    chunk_id\n    document_id\n    task_id\n    object\n    predicate\n    subject\n    triplet_id\n    indexing_state {\n      completion_cost\n      completion_tokens\n      content_tokens\n      embedding_cost\n      is_embedded\n      is_indexed_qa\n      is_indexed_triplet\n      is_parsed\n      is_summarized\n      prompt_cost\n      prompt_tokens\n    }\n  }\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "mutation KDBIndexingDocumentTaskCreate($session: Session!, $input: KdbIndexingDocumentTaskCreateInput!) {\n  kdbIndexingDocumentTaskCreate(session: $session, input: $input) {\n    task_id\n    document_id\n    chat_id\n    message_id\n    author_id\n    task_state\n    created_at\n    update_at\n    confirmed\n    version\n    error\n    statistics {\n      chunks_indexed_qa\n      chunks_indexed_triplet\n      chunks_total\n      current_indexing_speed\n      expected_finish_seconds\n      expected_finished_at\n      indexed_percent\n      indexing_started_at\n      llm_approximate_cost\n      llm_stats {\n        completion_cost\n        embeddings_cost\n        embeddings_count\n        prompt_cost\n        total_cost\n      }\n      pages\n      qa_total\n      total_tokens\n      triplets_total\n      indexed_for_seconds\n    }\n    config {\n      chunk_overlap_tokens\n      chunk_size_tokens\n      cost_limit\n      need_qa\n      qa_count_per_run\n      qa_model\n      force_confirm\n      instruction_for_qa\n    }\n  }\n}"): (typeof documents)["mutation KDBIndexingDocumentTaskCreate($session: Session!, $input: KdbIndexingDocumentTaskCreateInput!) {\n  kdbIndexingDocumentTaskCreate(session: $session, input: $input) {\n    task_id\n    document_id\n    chat_id\n    message_id\n    author_id\n    task_state\n    created_at\n    update_at\n    confirmed\n    version\n    error\n    statistics {\n      chunks_indexed_qa\n      chunks_indexed_triplet\n      chunks_total\n      current_indexing_speed\n      expected_finish_seconds\n      expected_finished_at\n      indexed_percent\n      indexing_started_at\n      llm_approximate_cost\n      llm_stats {\n        completion_cost\n        embeddings_cost\n        embeddings_count\n        prompt_cost\n        total_cost\n      }\n      pages\n      qa_total\n      total_tokens\n      triplets_total\n      indexed_for_seconds\n    }\n    config {\n      chunk_overlap_tokens\n      chunk_size_tokens\n      cost_limit\n      need_qa\n      qa_count_per_run\n      qa_model\n      force_confirm\n      instruction_for_qa\n    }\n  }\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "mutation KDBIndexingDocumentTaskError($session: Session!, $taskID: TaskID!, $version: Int!, $error: String!) {\n  kdbIndexingDocumentTaskError(\n    session: $session\n    taskID: $taskID\n    version: $version\n    error: $error\n  ) {\n    ...IndexingDocumentTaskFields\n  }\n}"): (typeof documents)["mutation KDBIndexingDocumentTaskError($session: Session!, $taskID: TaskID!, $version: Int!, $error: String!) {\n  kdbIndexingDocumentTaskError(\n    session: $session\n    taskID: $taskID\n    version: $version\n    error: $error\n  ) {\n    ...IndexingDocumentTaskFields\n  }\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "mutation KDBIndexingDocumentTaskTransitionState($session: Session!, $taskID: TaskID!, $toState: IndexingDocumentTaskState!, $version: Int!) {\n  kdbIndexingDocumentTaskTransitionState(\n    session: $session\n    taskID: $taskID\n    toState: $toState\n    version: $version\n  ) {\n    ...IndexingDocumentTaskFields\n  }\n}"): (typeof documents)["mutation KDBIndexingDocumentTaskTransitionState($session: Session!, $taskID: TaskID!, $toState: IndexingDocumentTaskState!, $version: Int!) {\n  kdbIndexingDocumentTaskTransitionState(\n    session: $session\n    taskID: $taskID\n    toState: $toState\n    version: $version\n  ) {\n    ...IndexingDocumentTaskFields\n  }\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "query MarketplaceAgent($session: Session!, $agent_id: AgentID!) {\n  marketplaceAgent(session: $session, agent_id: $agent_id) {\n    agent_id\n    username\n    first_name\n    last_name\n    avatar\n    role\n    can_answer\n    owner_id\n    chain_graph_id\n    llm_config {\n      model\n      max_tokens\n      temperature\n    }\n    template_params\n    purpose\n    prompt\n    self_awareness\n    tools {\n      name\n    }\n    llm_model\n    chat_history_config {\n      messages_count\n      tokens_limit\n    }\n  }\n}"): (typeof documents)["query MarketplaceAgent($session: Session!, $agent_id: AgentID!) {\n  marketplaceAgent(session: $session, agent_id: $agent_id) {\n    agent_id\n    username\n    first_name\n    last_name\n    avatar\n    role\n    can_answer\n    owner_id\n    chain_graph_id\n    llm_config {\n      model\n      max_tokens\n      temperature\n    }\n    template_params\n    purpose\n    prompt\n    self_awareness\n    tools {\n      name\n    }\n    llm_model\n    chat_history_config {\n      messages_count\n      tokens_limit\n    }\n  }\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "fragment agentFields on AgentMeta {\n  agent_id\n  username\n  owner_id\n  first_name\n  last_name\n  avatar\n  role\n  can_answer\n  chain_graph_id\n  skeleton\n  template_params\n  llm_config {\n    model\n    temperature\n    max_tokens\n  }\n  is_agent\n  deployment_status\n  prompt\n  chat_history_config {\n    messages_count\n    tokens_limit\n  }\n  llm_model\n  purpose\n  self_awareness\n  tools {\n    name\n  }\n}\n\nfragment agentCollectionFields on AgentCollection {\n  collection_id\n  title\n  description\n  owner_id\n  order\n  updated_at\n  agents {\n    ...agentFields\n  }\n}\n\nquery MarketplaceAgents($session: Session!) {\n  marketplaceAgents(session: $session) {\n    ...agentCollectionFields\n  }\n}"): (typeof documents)["fragment agentFields on AgentMeta {\n  agent_id\n  username\n  owner_id\n  first_name\n  last_name\n  avatar\n  role\n  can_answer\n  chain_graph_id\n  skeleton\n  template_params\n  llm_config {\n    model\n    temperature\n    max_tokens\n  }\n  is_agent\n  deployment_status\n  prompt\n  chat_history_config {\n    messages_count\n    tokens_limit\n  }\n  llm_model\n  purpose\n  self_awareness\n  tools {\n    name\n  }\n}\n\nfragment agentCollectionFields on AgentCollection {\n  collection_id\n  title\n  description\n  owner_id\n  order\n  updated_at\n  agents {\n    ...agentFields\n  }\n}\n\nquery MarketplaceAgents($session: Session!) {\n  marketplaceAgents(session: $session) {\n    ...agentCollectionFields\n  }\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "fragment MessageFields on Message {\n  attachments {\n    filename\n    id\n    mime_type\n    size\n    url\n  }\n  author\n  chat_id\n  deleted\n  error\n  finished\n  id\n  is_system\n  meta\n  need_answer\n  participant {\n    agent_id\n    avatar\n    first_name\n    is_agent\n    last_name\n    llm_model\n    meta\n    participant_id\n    purpose\n    role\n    self_awareness\n    tools {\n      name\n    }\n    username\n  }\n  reply_to\n  text\n  time\n  total_usage_cost\n  type\n  version\n  signals {\n    message_id\n    ... on AgentTriggeredSignal {\n      message_id\n      agent_id\n    }\n  }\n}"): (typeof documents)["fragment MessageFields on Message {\n  attachments {\n    filename\n    id\n    mime_type\n    size\n    url\n  }\n  author\n  chat_id\n  deleted\n  error\n  finished\n  id\n  is_system\n  meta\n  need_answer\n  participant {\n    agent_id\n    avatar\n    first_name\n    is_agent\n    last_name\n    llm_model\n    meta\n    participant_id\n    purpose\n    role\n    self_awareness\n    tools {\n      name\n    }\n    username\n  }\n  reply_to\n  text\n  time\n  total_usage_cost\n  type\n  version\n  signals {\n    message_id\n    ... on AgentTriggeredSignal {\n      message_id\n      agent_id\n    }\n  }\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "mutation AuthAgentLogin($agentID: AgentID!, $session: Session!) {\n  authAgentLogin(agentID: $agentID, session: $session) {\n    session\n    user_profile {\n      id\n      name\n      picture\n    }\n  }\n}"): (typeof documents)["mutation AuthAgentLogin($agentID: AgentID!, $session: Session!) {\n  authAgentLogin(agentID: $agentID, session: $session) {\n    session\n    user_profile {\n      id\n      name\n      picture\n    }\n  }\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "mutation AppendUsages($session: Session!, $usages: [UsageInput!]!) {\n  appendUsages(session: $session, usages: $usages)\n}"): (typeof documents)["mutation AppendUsages($session: Session!, $usages: [UsageInput!]!) {\n  appendUsages(session: $session, usages: $usages)\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "mutation AuthMetamaskLogin($input: MetamaskLoginInput!) {\n  authMetamaskLogin(input: $input) {\n    session\n    user_profile {\n      id\n      name\n      picture\n    }\n  }\n}"): (typeof documents)["mutation AuthMetamaskLogin($input: MetamaskLoginInput!) {\n  authMetamaskLogin(input: $input) {\n    session\n    user_profile {\n      id\n      name\n      picture\n    }\n  }\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "mutation UploadAttachment($session: Session!, $attachment: AttachmentBlob!) {\n  uploadAttachment(session: $session, attachment: $attachment) {\n    id\n    mime_type\n    url\n  }\n}"): (typeof documents)["mutation UploadAttachment($session: Session!, $attachment: AttachmentBlob!) {\n  uploadAttachment(session: $session, attachment: $attachment) {\n    id\n    mime_type\n    url\n  }\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "mutation VoiceToText($session: Session!, $attachment_id: AttachmentID!) {\n  voiceToText(session: $session, attachment_id: $attachment_id) {\n    language\n    tokens\n    text\n    avg_logprob\n    no_speech_prob\n    temperature\n    compression_ratio\n  }\n}"): (typeof documents)["mutation VoiceToText($session: Session!, $attachment_id: AttachmentID!) {\n  voiceToText(session: $session, attachment_id: $attachment_id) {\n    language\n    tokens\n    text\n    avg_logprob\n    no_speech_prob\n    temperature\n    compression_ratio\n  }\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "subscription SubscribeChatRooms($session: Session!, $limit_chats: Int) {\n  subscribeChatRooms(session: $session, limit_chats: $limit_chats) {\n    sub_id\n    event\n    chat_rooms {\n      id\n      name\n      author\n      created_at\n      deleted_at\n      deleted\n      participants {\n        participant_id\n        agent_id\n        first_name\n        last_name\n        username\n        avatar\n        is_agent\n        role\n        purpose\n        self_awareness\n        tools {\n          name\n        }\n        llm_model\n        meta\n      }\n      meta\n    }\n    participants {\n      participant_id\n      agent_id\n      avatar\n      first_name\n      is_agent\n      last_name\n      purpose\n      role\n      self_awareness\n      username\n      tools {\n        name\n      }\n      llm_model\n      meta\n    }\n  }\n}"): (typeof documents)["subscription SubscribeChatRooms($session: Session!, $limit_chats: Int) {\n  subscribeChatRooms(session: $session, limit_chats: $limit_chats) {\n    sub_id\n    event\n    chat_rooms {\n      id\n      name\n      author\n      created_at\n      deleted_at\n      deleted\n      participants {\n        participant_id\n        agent_id\n        first_name\n        last_name\n        username\n        avatar\n        is_agent\n        role\n        purpose\n        self_awareness\n        tools {\n          name\n        }\n        llm_model\n        meta\n      }\n      meta\n    }\n    participants {\n      participant_id\n      agent_id\n      avatar\n      first_name\n      is_agent\n      last_name\n      purpose\n      role\n      self_awareness\n      username\n      tools {\n        name\n      }\n      llm_model\n      meta\n    }\n  }\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "subscription SubscribeMessages($session: Session!, $chat_id: ChatID!, $limitMessages: Int! = 100) {\n  subscribeMessages(\n    session: $session\n    chat_id: $chat_id\n    limitMessages: $limitMessages\n  ) {\n    event\n    sub_id\n    message {\n      ...MessageFields\n    }\n    messages {\n      ...MessageFields\n    }\n  }\n}"): (typeof documents)["subscription SubscribeMessages($session: Session!, $chat_id: ChatID!, $limitMessages: Int! = 100) {\n  subscribeMessages(\n    session: $session\n    chat_id: $chat_id\n    limitMessages: $limitMessages\n  ) {\n    event\n    sub_id\n    message {\n      ...MessageFields\n    }\n    messages {\n      ...MessageFields\n    }\n  }\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "query GetUserProfile($session: Session!) {\n  userProfile(session: $session) {\n    email\n    externalAccounts {\n      ID\n      providerID\n    }\n    id\n    name\n    picture\n    role\n    tariffCurrent\n    tariffExpires\n  }\n}"): (typeof documents)["query GetUserProfile($session: Session!) {\n  userProfile(session: $session) {\n    email\n    externalAccounts {\n      ID\n      providerID\n    }\n    id\n    name\n    picture\n    role\n    tariffCurrent\n    tariffExpires\n  }\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "fragment variableFields on Variable {\n  id\n  namespace\n  key\n  value {\n    type\n    value\n  }\n  createdAt\n  updatedAt\n}\n\nquery GetVariable($session: Session!, $namespace: NamespaceInput!, $key: String!) {\n  getVariable(session: $session, namespace: $namespace, key: $key) {\n    variable {\n      ...variableFields\n    }\n  }\n}\n\nquery GetVariables($session: Session!, $namespace: NamespaceInput!) {\n  getVariables(session: $session, namespace: $namespace) {\n    variables {\n      ...variableFields\n    }\n  }\n}\n\nmutation SetVariable($session: Session!, $namespace: NamespaceInput!, $key: String!, $value: VariableValueInput!) {\n  setVariable(session: $session, namespace: $namespace, key: $key, value: $value) {\n    variable {\n      ...variableFields\n    }\n  }\n}\n\nmutation SetVariables($session: Session!, $namespace: NamespaceInput!, $variables: [KeyValueInput!]!) {\n  setVariables(session: $session, namespace: $namespace, variables: $variables) {\n    variables {\n      ...variableFields\n    }\n  }\n}\n\nmutation DeleteVariable($session: Session!, $namespace: NamespaceInput!, $key: String!) {\n  deleteVariable(session: $session, namespace: $namespace, key: $key)\n}\n\nmutation DeleteVariables($session: Session!, $namespace: NamespaceInput!) {\n  deleteVariables(session: $session, namespace: $namespace)\n}\n\nmutation AppendVariable($session: Session!, $namespace: NamespaceInput!, $key: String!, $value: VariableValueInput!) {\n  appendVariable(\n    session: $session\n    namespace: $namespace\n    key: $key\n    value: $value\n  ) {\n    variable {\n      ...variableFields\n    }\n  }\n}"): (typeof documents)["fragment variableFields on Variable {\n  id\n  namespace\n  key\n  value {\n    type\n    value\n  }\n  createdAt\n  updatedAt\n}\n\nquery GetVariable($session: Session!, $namespace: NamespaceInput!, $key: String!) {\n  getVariable(session: $session, namespace: $namespace, key: $key) {\n    variable {\n      ...variableFields\n    }\n  }\n}\n\nquery GetVariables($session: Session!, $namespace: NamespaceInput!) {\n  getVariables(session: $session, namespace: $namespace) {\n    variables {\n      ...variableFields\n    }\n  }\n}\n\nmutation SetVariable($session: Session!, $namespace: NamespaceInput!, $key: String!, $value: VariableValueInput!) {\n  setVariable(session: $session, namespace: $namespace, key: $key, value: $value) {\n    variable {\n      ...variableFields\n    }\n  }\n}\n\nmutation SetVariables($session: Session!, $namespace: NamespaceInput!, $variables: [KeyValueInput!]!) {\n  setVariables(session: $session, namespace: $namespace, variables: $variables) {\n    variables {\n      ...variableFields\n    }\n  }\n}\n\nmutation DeleteVariable($session: Session!, $namespace: NamespaceInput!, $key: String!) {\n  deleteVariable(session: $session, namespace: $namespace, key: $key)\n}\n\nmutation DeleteVariables($session: Session!, $namespace: NamespaceInput!) {\n  deleteVariables(session: $session, namespace: $namespace)\n}\n\nmutation AppendVariable($session: Session!, $namespace: NamespaceInput!, $key: String!, $value: VariableValueInput!) {\n  appendVariable(\n    session: $session\n    namespace: $namespace\n    key: $key\n    value: $value\n  ) {\n    variable {\n      ...variableFields\n    }\n  }\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "query ReadSecret($session: Session!, $id: SecretID!, $publicKey: ECDHPublicKeyP256!) {\n  secret(session: $session, id: $id, publicKey: $publicKey) {\n    hkdfNonce\n    publicKey\n    secret {\n      encrypted\n      metadata {\n        type\n      }\n    }\n  }\n}"): (typeof documents)["query ReadSecret($session: Session!, $id: SecretID!, $publicKey: ECDHPublicKeyP256!) {\n  secret(session: $session, id: $id, publicKey: $publicKey) {\n    hkdfNonce\n    publicKey\n    secret {\n      encrypted\n      metadata {\n        type\n      }\n    }\n  }\n}"];

export function graphql(source: string) {
  return (documents as any)[source] ?? {};
}

export type DocumentType<TDocumentNode extends DocumentNode<any, any>> = TDocumentNode extends DocumentNode<  infer TType,  any>  ? TType  : never;
